<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>React学习笔记 | 技术博客</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css><link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&display=swap" rel=stylesheet><style>:root{--nav-height:60px;--toc-width:280px;--content-padding:40px;--primary-color:#3498db;--text-color:#333;--light-gray:#f5f5f5;--border-color:#eaeaea}*{box-sizing:border-box;margin:0;padding:0}body{font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,sans-serif;color:var(--text-color);line-height:1.6;padding-top:var(--nav-height);overflow-x:hidden}.top-nav{position:fixed;top:0;left:0;right:0;height:var(--nav-height);background:#fff;box-shadow:0 2px 10px rgba(0,0,0,.1);display:flex;align-items:center;padding:0 30px;z-index:1000}.nav-container{width:100%;max-width:1400px;margin:0 auto;display:flex;justify-content:space-between;align-items:center}.site-title{font-size:1.4rem;font-weight:700;color:var(--primary-color);text-decoration:none}.nav-links{display:flex;gap:25px}.nav-links a{color:var(--text-color);text-decoration:none;font-size:1rem;transition:color .3s}.nav-links a:hover{color:var(--primary-color)}.main-container{display:flex;max-width:1400px;margin:0 auto;padding:20px}.toc-container{position:sticky;top:calc(var(--nav-height) + 20px);align-self:flex-start;width:var(--toc-width);padding:20px;margin-right:30px;max-height:calc(100vh - var(--nav-height) - 40px);overflow-y:auto;background:var(--light-gray);border-radius:8px;scroll-behavior:auto;overscroll-behavior:contain}.toc-title{font-size:1.2rem;margin-bottom:15px;padding-bottom:10px;border-bottom:2px solid var(--primary-color)}.toc ul{list-style:none;padding-left:15px}.toc li{margin-bottom:8px;position:relative}.toc a{color:var(--text-color);text-decoration:none;display:block;padding:5px 0 5px 10px;transition:all .2s;font-size:.95rem;border-left:2px solid transparent}.toc a:hover{color:var(--primary-color);transform:translateX(5px)}.toc a.active{color:var(--primary-color);font-weight:700;border-left:3px solid var(--primary-color);background:rgba(52,152,219,5%);transform:translateX(5px)}.content-container{flex:1;background:#fff;padding:var(--content-padding);border-radius:8px;box-shadow:0 2px 15px rgba(0,0,0,5%)}.article-header{margin-bottom:30px;border-bottom:1px solid var(--border-color);padding-bottom:20px}.article-title{font-size:2rem;margin-bottom:10px;color:#2c3e50}.article-meta{display:flex;gap:20px;color:#7f8c8d;font-size:.9rem;margin-bottom:15px}.article-content{line-height:1.8}.article-content h2{font-size:1.6rem;margin:2rem 0 1rem;padding-bottom:.5rem;border-bottom:1px solid var(--border-color);scroll-margin-top:calc(var(--nav-height) + 20px)}.article-content h3{font-size:1.3rem;margin:1.5rem 0 .8rem;scroll-margin-top:calc(var(--nav-height) + 20px)}.article-content img{max-width:100%;height:auto;border-radius:6px;margin:1.5rem 0;box-shadow:0 3px 10px rgba(0,0,0,.1)}.article-content pre{position:relative;background:#f7f7f7;color:#242424;border-left:4px solid #04b04f;border-radius:8px;padding:1.5rem 1rem 1rem;margin:1.5rem 0;overflow:auto;box-shadow:0 1px 3px rgba(0,0,0,.1);max-height:40vh;white-space:pre-wrap;font-family:fira code,Menlo,Monaco,Consolas,monospace;font-size:.9rem;line-height:1.5;scrollbar-width:thin;scrollbar-color:#c4c4c4 #f7f7f7}.article-content code{font-family:inherit;color:inherit!important;background:0 0!important;padding:0;text-shadow:none!important;font-size:.9rem}.hljs-meta,.hljs-built_in{color:#04b04f}.hljs-attribute{color:#e91e63}.hljs-string{color:#2e7d32}.hljs-number{color:#2196f3}.article-content pre::-webkit-scrollbar{width:12px;height:12px}.article-content pre::-webkit-scrollbar{width:12px;height:12px}.article-content pre::-webkit-scrollbar-thumb{background:#04b04f;opacity:.6;border:3px solid #f7f7f7}.article-content pre::-webkit-scrollbar-track{background:#f7f7f7;border-radius:6px}.copy-code{position:absolute;top:10px;right:15px;background:rgba(0,0,0,.1);border:1px solid rgba(0,0,0,.2);color:#242424;border-radius:4px;padding:3px 8px;font-size:.8rem;cursor:pointer;transition:all .3s;opacity:0;z-index:10}pre:hover .copy-code{opacity:1}.copy-code:hover{background:rgba(0,0,0,.2)}.copy-code.copied{background:#28a745;color:#fff;border-color:#28a745}@media(max-width:1024px){.toc-container{width:240px;padding:15px}.content-container{padding:25px}}@media(max-width:768px){.main-container{flex-direction:column}.toc-container{position:static;width:100%;margin-right:0;margin-bottom:30px;max-height:none}.article-title{font-size:1.8rem}.article-content pre{max-height:50vh;padding-right:10px}}</style></head><body><nav class=top-nav><div class=nav-container><a href=/ class=site-title>技术博客</a><div class=nav-links><a href=/>首页</a>
<a href=/posts/>所有文章</a>
<a href=/categories/>分类</a>
<a href=/tags/>标签</a></div></div></nav><div class=main-container><aside class=toc-container><h3 class=toc-title>目录</h3><div class=toc><nav id=TableOfContents><ul><li><ul><li><a href=#构建一个简单的react项目>构建一个简单的react项目</a><ul><li><a href=#项目的基本结构>项目的基本结构</a></li></ul></li><li><a href=#jsx实践>JSX实践</a><ul><li><a href=#react如何使用javascript>React如何使用javascript</a></li><li><a href=#在jsx中应用变量表达式>在JSX中应用变量、表达式</a></li></ul></li><li><a href=#react--component>React Component</a></li><li><a href=#jsx中的注意事项>jsx中的注意事项</a><ul><li><a href=#几个特别的属性>几个特别的属性</a></li><li><a href=#reuse--of--component>reuse of component</a></li></ul></li><li><a href=#react的state管理todo-list>React的state管理（todo-list）</a></li><li><a href=#nextjs>Next.js</a></li><li><a href=#react-bootstrap>React bootStrap</a><ul><li><a href=#react-bootstrap-是什么><strong>React Bootstrap 是什么</strong></a></li><li><a href=#如何使用-react-bootstrap><strong>如何使用 React Bootstrap</strong></a></li></ul></li><li><a href=#关于react整体思路的总结>关于React整体思路的总结：</a></li></ul></li></ul></nav></div></aside><article class=content-container><header class=article-header><h1 class=article-title>React学习笔记</h1><div class=article-meta><span>📅 2025年8月29日</span>
<span>📁 <a href=/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB>默认分类</a></span></div></header><div class=article-content><h3 id=构建一个简单的react项目>构建一个简单的react项目</h3><p>使用vite作为工具构建一个简单的react项目，理解react项目的基本框架和运行原理</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>#先安装好node，最好下载最新的lts版，目前是22.18
</span></span><span class=line><span class=cl>#装好node之后，在bash下使用node  -v，出现22.18的版本号就是装好了，顺便在显示一下npm  -v
</span></span><span class=line><span class=cl>npm create vite@latest moz-todo-react -- --template react
</span></span></code></pre></div><h4 id=项目的基本结构>项目的基本结构</h4><p>生成的项目结构如下图：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># 在windows的cmd下使用dir  /B  &gt; dirs.txt  生成项目的目录和文件列表。/B  是bare的首字母，表示输出采用无装饰的格式
</span></span><span class=line><span class=cl># 手动输入+--;\--表示最后一个同级项目
</span></span><span class=line><span class=cl>LearnReact
</span></span><span class=line><span class=cl>  +--node_modules
</span></span><span class=line><span class=cl>  +--public
</span></span><span class=line><span class=cl>  +--src
</span></span><span class=line><span class=cl>    |--assets
</span></span><span class=line><span class=cl>    |--components
</span></span><span class=line><span class=cl>    |--App.jsx
</span></span><span class=line><span class=cl>    |--index.css
</span></span><span class=line><span class=cl>    |-- main.jsx
</span></span><span class=line><span class=cl>  +--.gitignore
</span></span><span class=line><span class=cl>  +--eslint.config.js
</span></span><span class=line><span class=cl>  +--index.html
</span></span><span class=line><span class=cl>  +--package.json
</span></span><span class=line><span class=cl>  +--package-lock.json
</span></span><span class=line><span class=cl>  +--README.md
</span></span><span class=line><span class=cl>  \--vite.config.js
</span></span></code></pre></div><h5 id=indexhtml>index.html</h5><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=cp>&lt;!doctype html&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>html</span> <span class=na>lang</span><span class=o>=</span><span class=s>&#34;en&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>&lt;</span><span class=nt>head</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>meta</span> <span class=na>charset</span><span class=o>=</span><span class=s>&#34;UTF-8&#34;</span> <span class=p>/&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>link</span> <span class=na>rel</span><span class=o>=</span><span class=s>&#34;icon&#34;</span> <span class=na>type</span><span class=o>=</span><span class=s>&#34;image/svg+xml&#34;</span> <span class=na>href</span><span class=o>=</span><span class=s>&#34;/vite.svg&#34;</span> <span class=p>/&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>meta</span> <span class=na>name</span><span class=o>=</span><span class=s>&#34;viewport&#34;</span> <span class=na>content</span><span class=o>=</span><span class=s>&#34;width=device-width, initial-scale=1.0&#34;</span> <span class=p>/&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>title</span><span class=p>&gt;</span>TodoMatic<span class=p>&lt;/</span><span class=nt>title</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>&lt;/</span><span class=nt>head</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>&lt;</span><span class=nt>body</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>div</span> <span class=na>id</span><span class=o>=</span><span class=s>&#34;root&#34;</span><span class=p>&gt;&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>script</span> <span class=na>type</span><span class=o>=</span><span class=s>&#34;module&#34;</span> <span class=na>src</span><span class=o>=</span><span class=s>&#34;/src/main.jsx&#34;</span><span class=p>&gt;&lt;/</span><span class=nt>script</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>&lt;/</span><span class=nt>body</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>html</span><span class=p>&gt;</span>
</span></span></code></pre></div><ul><li><p><code>&lt;script type="module" src="/src/main.jsx">&lt;/script></code>。在index.html文件中加载了项目根目录下src目录下的main.jsx文件。然后main.jsx文件里又加载了App.jsx文件，App.jsx文件又可以使用子组件，比如components下的组件。加载这样就形成了一个完整的调佣链条：<code>index.html</code>，<code>main.jsx</code>、<code>App.jsx</code>、childComponentsxxx.jsx</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>index.html is the most important top-level file. Vite injects your code into this file so that  browser can run it.
</span></span></code></pre></div></li><li><p><code>&lt;div id=""root>&lt;/div></code> 这句是表示了这个<code>&lt;div> &lt;/div></code>是整个虚拟dom的根元素，为后面动态添加子元素用的吧，我是这么理解。</p></li></ul><h5 id=mainjsx>main.jsx</h5><p>这个文件是程序的入口点，初始状态如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>import { StrictMode } from &#34;react&#34;;
</span></span><span class=line><span class=cl>import { createRoot } from &#34;react-dom/client&#34;;
</span></span><span class=line><span class=cl>import &#34;./index.css&#34;;
</span></span><span class=line><span class=cl>import App from &#34;./App.jsx&#34;;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>createRoot(document.getElementById(&#34;root&#34;)).render(
</span></span><span class=line><span class=cl>  &lt;StrictMode&gt;
</span></span><span class=line><span class=cl>    &lt;App /&gt;
</span></span><span class=line><span class=cl>  &lt;/StrictMode&gt;,
</span></span><span class=line><span class=cl>);
</span></span></code></pre></div><p><code>main.jsx</code>文件的最上边是<code>import</code>部分，用来导入需要的JavaScript 模块和资源。前边两条语句是导入react库文件，这些不带路径和扩展名称的库，在package.json文件里作为依赖列出来。后边两条带有<code>./</code>路径的是指当前项目文件。</p><p>在下面的<code>createRoot()</code>函数里，看到了在<code>index.html</code>文件里的<code>root</code>，这样就关联到了，把<code>id=root</code>的<code>&lt;div>&lt;/div></code>创建为虚拟<code>DOM</code>的根元素，然后调用这个根元素的<code>render()</code>方法，把自定义的<code>&lt;App /></code>组件添加在根元素下面。</p><p><code>&lt;App /></code>这样的写法，是jsx里双关的表示方法：<strong>以类HTML标签的书写形式，实现函数的调用（组件的复用）</strong></p><ul><li>类似HTML标签的写法，不过这里App首字母大写，表示自定义，标准的HTML标签是小写</li><li><code>App</code>是一个自定义的component，是一个独立的文件，同时又是组件里的函数名称。</li></ul><p>​ 这里的<code>&lt;App /></code>书写方法还可以带参数，类似<code>html</code>标签里的属性和值的写法一样，下面的代码会显示这一特征。</p><ul><li><p>By writing <code>&lt;App /></code> as this JSX expression, we&rsquo;re telling React to call the <code>App()</code> <em>function</em>, which renders the <code>App</code> <em>component</em> inside the root node.</p><p>[我的翻译-通过把<app>作为jsx表达式传递给render作为参数，告诉 React调用App（）函数在root节点下渲染App组件。]</p></li></ul><h5 id=appjsx>App.jsx</h5><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>import</span> <span class=p>{</span> <span class=n>useState</span> <span class=p>}</span> <span class=n>from</span> <span class=s2>&#34;react&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>import</span> <span class=n>viteLogo</span> <span class=n>from</span> <span class=s2>&#34;/vite.svg&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>import</span> <span class=n>reactLogo</span> <span class=n>from</span> <span class=s2>&#34;./assets/react.svg&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>import</span> <span class=s2>&#34;./App.css&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>function</span> <span class=n>App</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=p>[</span><span class=n>count</span><span class=p>,</span> <span class=n>setCount</span><span class=p>]</span> <span class=o>=</span> <span class=n>useState</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=n>div</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=o>&lt;</span><span class=n>a</span> <span class=n>href</span><span class=o>=</span><span class=s2>&#34;https://vite.dev&#34;</span> <span class=n>target</span><span class=o>=</span><span class=s2>&#34;_blank&#34;</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>          <span class=o>&lt;</span><span class=n>img</span> <span class=n>src</span><span class=o>=</span><span class=p>{</span><span class=n>viteLogo</span><span class=p>}</span> <span class=n>className</span><span class=o>=</span><span class=s2>&#34;logo&#34;</span> <span class=n>alt</span><span class=o>=</span><span class=s2>&#34;Vite logo&#34;</span> <span class=o>/&gt;</span>
</span></span><span class=line><span class=cl>        <span class=o>&lt;/</span><span class=n>a</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=o>&lt;</span><span class=n>a</span> <span class=n>href</span><span class=o>=</span><span class=s2>&#34;https://react.dev&#34;</span> <span class=n>target</span><span class=o>=</span><span class=s2>&#34;_blank&#34;</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>          <span class=o>&lt;</span><span class=n>img</span> <span class=n>src</span><span class=o>=</span><span class=p>{</span><span class=n>reactLogo</span><span class=p>}</span> <span class=n>className</span><span class=o>=</span><span class=s2>&#34;logo react&#34;</span> <span class=n>alt</span><span class=o>=</span><span class=s2>&#34;React logo&#34;</span> <span class=o>/&gt;</span>
</span></span><span class=line><span class=cl>        <span class=o>&lt;/</span><span class=n>a</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;/</span><span class=n>div</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=n>h1</span><span class=o>&gt;</span><span class=n>Vite</span> <span class=o>+</span> <span class=n>React</span><span class=o>&lt;/</span><span class=n>h1</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=n>div</span> <span class=n>className</span><span class=o>=</span><span class=s2>&#34;card&#34;</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=o>&lt;</span><span class=n>button</span> <span class=n>onClick</span><span class=o>=</span><span class=p>{()</span> <span class=o>=&gt;</span> <span class=n>setCount</span><span class=p>((</span><span class=n>count</span><span class=p>)</span> <span class=o>=&gt;</span> <span class=n>count</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)}</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>          <span class=n>count</span> <span class=n>is</span> <span class=p>{</span><span class=n>count</span><span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=o>&lt;/</span><span class=n>button</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=o>&lt;</span><span class=n>p</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>          <span class=n>Edit</span> <span class=o>&lt;</span><span class=n>code</span><span class=o>&gt;</span><span class=n>src</span><span class=o>/</span><span class=n>App</span><span class=o>.</span><span class=n>jsx</span><span class=o>&lt;/</span><span class=n>code</span><span class=o>&gt;</span> <span class=ow>and</span> <span class=n>save</span> <span class=n>to</span> <span class=n>test</span> <span class=n>HMR</span>
</span></span><span class=line><span class=cl>        <span class=o>&lt;/</span><span class=n>p</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;/</span><span class=n>div</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=n>p</span> <span class=n>className</span><span class=o>=</span><span class=s2>&#34;read-the-docs&#34;</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=n>Click</span> <span class=n>on</span> <span class=n>the</span> <span class=n>Vite</span> <span class=ow>and</span> <span class=n>React</span> <span class=n>logos</span> <span class=n>to</span> <span class=n>learn</span> <span class=n>more</span>
</span></span><span class=line><span class=cl>      <span class=o>&lt;/</span><span class=n>p</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;/&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>export</span> <span class=n>default</span> <span class=n>App</span><span class=p>;</span>
</span></span></code></pre></div><p><code>App.jsx</code>文件包含三部分</p><ul><li><p>import部分 引用react库文件、运行时需要的图片、CSS文件</p><ul><li>The final statement imports the CSS related to our <code>&lt;App /></code> component. Note that there is no variable name and no <code>from</code> directive. This is called a <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#import_a_module_for_its_side_effects_only><em>side-effect import</em></a> — it doesn&rsquo;t import any value into the JavaScript file, but it tells Vite to add the referenced CSS file to the final code output, so that it can be used in the browser.</li></ul></li><li><p>function App() 初始化本地的数据[count,setCount]=useState，然后用return语句返回一个&lt;> &lt;/>包裹的jsx表达式，这个jsx表达式类似HTML中的元素，可是单个按钮，可以是整个form组件和其包裹的所有子元素，甚至整个页面的DOM树。</p><ul><li><p>App是一个react compotent，它的名称使用upper camel case样式，名称中多个单词的首字母大写，比如HelloWorld。如果把这函数名称写成小写的<code>app</code>，浏览器就会报错。</p></li><li><p>return 返回的jsx表达式类似标准的HTML元素，表示了在浏览器渲染的界面。但是它不是HTML元素，是jsx表达式，最后是由Babel编译，每一个jsx元素都被转换为React.createElement()函数的调用，多个元素嵌套的话，就会转为React.createElement()函数的嵌套调用。</p><ul><li><p>return <code>&lt;> jsx expression &lt;/></code> 。当返回的同级元素多于一个时就要用jsx fragmen（<code>&lt;> &lt;/></code>）包裹。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>#如果返回的是单个元素则不需要&lt;&gt; &lt;/&gt;包裹
</span></span><span class=line><span class=cl>&lt;h1&gt;one expression&lt;/h1&gt;  
</span></span><span class=line><span class=cl>#如果返回的是多个同级元素，要用&lt;&gt; &lt;/&gt;包裹
</span></span><span class=line><span class=cl>&lt;&gt;
</span></span><span class=line><span class=cl>  &lt;p&gt;first  paragraph  &lt;/p&gt;
</span></span><span class=line><span class=cl>  &lt;p2&gt;second  paragraph&lt;/p&gt;
</span></span><span class=line><span class=cl>&lt;/&gt;
</span></span><span class=line><span class=cl>#最外层是一个元素的嵌套多个元素，也不需要&lt;&gt; &lt;/&gt;包裹
</span></span><span class=line><span class=cl>&lt;div&gt;
</span></span><span class=line><span class=cl>   &lt;span&gt; one  &lt;/span&gt;
</span></span><span class=line><span class=cl>   &lt;span&gt;  two &lt;/span&gt;
</span></span><span class=line><span class=cl>&lt;/div&gt;
</span></span></code></pre></div></li></ul></li></ul></li><li><p>export default App</p><ul><li>导出默认的函数可以让别的组件使用</li></ul></li></ul><h5 id=reactcreateelement>React.createElement</h5><p><code>React.createElement()</code> <strong>是 React 框架自身的核心 API</strong>，而非标准 JavaScript 库（如 DOM API 或 ECMAScript 规范）。程序代码里并没有看到这个函数，但是这些组件函数返回的jsx表达式，最后都是由Babel转换为对React.createElement()函数的调用，最终转换为javascript代码，而React内部是通过javascript对象来保存这些描述性的渲染数据。</p><ul><li>虚拟 DOM 的创建（<code>React.createElement</code>）</li></ul><p>当调用 <code>React.createElement()</code> 时，React 会返回一个虚拟 DOM 对象（<code>ReactElement</code>），它是一个纯 JavaScript 对象，描述了要渲染的 UI 结构</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>element</span> <span class=o>=</span> <span class=nx>React</span><span class=p>.</span><span class=nx>createElement</span><span class=p>(</span><span class=s1>&#39;div&#39;</span><span class=p>,</span> <span class=p>{</span> <span class=nx>className</span><span class=o>:</span> <span class=s1>&#39;box&#39;</span> <span class=p>},</span> <span class=s1>&#39;Hello&#39;</span><span class=p>);</span>
</span></span></code></pre></div><p>返回的element对象的数据结构如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>  type: &#39;div&#39;,          // 标签名或组件
</span></span><span class=line><span class=cl>  props: {              // 属性和子元素
</span></span><span class=line><span class=cl>    className: &#39;box&#39;,
</span></span><span class=line><span class=cl>    children: &#39;Hello&#39;
</span></span><span class=line><span class=cl>  },
</span></span><span class=line><span class=cl>  key:,
</span></span><span class=line><span class=cl>  ref:,
</span></span><span class=line><span class=cl>  $$typeof: Symbol.for(&#39;react.element&#39;), // React 内部标识
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>这个javascript对象本身并不会直接渲染到页面，它只是一个“蓝图”，告诉 React 后续应该如何构建真实的 DOM。</p><ul><li>渲染为真实 DOM（<code>ReactDOM.render</code>）</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>#旧版同步渲染
</span></span><span class=line><span class=cl>ReactDOM.render(
</span></span><span class=line><span class=cl>  &lt;App tasks={DATA} /&gt;,
</span></span><span class=line><span class=cl>  document.getElementById(&#39;root&#39;)
</span></span><span class=line><span class=cl>);
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>#新版异步渲染
</span></span><span class=line><span class=cl>createRoot(document.getElementById(&#39;root&#39;)).render(
</span></span><span class=line><span class=cl>  &lt;StrictMode&gt;
</span></span><span class=line><span class=cl>    &lt;App tasks={DATA}/&gt;
</span></span><span class=line><span class=cl>  &lt;/StrictMode&gt;,
</span></span><span class=line><span class=cl>)
</span></span></code></pre></div><p><code>ReactDOM.render(element, container)</code> 的作用是<strong>将虚拟 DOM 转换为真实 DOM，并挂载到指定的容器中</strong>。它的核心步骤如下：</p><p>(1) 递归处理虚拟 DOM 树</p><p>React 会从根元素（<code>element</code>）开始，递归遍历整个虚拟 DOM 树，逐层创建真实的 DOM 节点。</p><p>(2) 创建真实 DOM 节点</p><ul><li>根据 <code>element.type</code>（如 <code>'div'</code>）调用 <code>document.createElement()</code> 创建对应的 DOM 元素。</li><li>如果 <code>type</code> 是一个函数/类（即组件），则先执行组件函数，得到其返回的虚拟 DOM，再继续处理。</li></ul><p>(3) 设置属性和事件</p><ul><li>遍历 <code>element.props</code>，将属性（如 <code>className</code>、<code>style</code>）赋值给真实 DOM。</li><li>特殊属性（如 <code>onClick</code>）会被绑定为事件监听器。</li><li><code>children</code> 会被递归处理（可能是文本、数组或嵌套的虚拟 DOM）。</li></ul><p>(4) 挂载到容器</p><ul><li><p>将最终生成的真实 DOM 节点插入到传入的 <code>container</code> 中</p><p>简化的ReactDOM.render内部实现过程</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>function</span> <span class=n>render</span><span class=p>(</span><span class=n>element</span><span class=p>,</span> <span class=n>container</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=o>//</span> <span class=mf>1.</span> <span class=err>创建</span> <span class=n>DOM</span> <span class=err>节点</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>domNode</span> <span class=o>=</span> <span class=n>document</span><span class=o>.</span><span class=n>createElement</span><span class=p>(</span><span class=n>element</span><span class=o>.</span><span class=n>type</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=o>//</span> <span class=mf>2.</span> <span class=err>设置属性（排除</span> <span class=n>children</span><span class=err>）</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=n>propName</span> <span class=ow>in</span> <span class=n>element</span><span class=o>.</span><span class=n>props</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>propName</span> <span class=o>===</span> <span class=s1>&#39;children&#39;</span><span class=p>)</span> <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>domNode</span><span class=p>[</span><span class=n>propName</span><span class=p>]</span> <span class=o>=</span> <span class=n>element</span><span class=o>.</span><span class=n>props</span><span class=p>[</span><span class=n>propName</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=o>//</span> <span class=mf>3.</span> <span class=err>处理</span> <span class=n>children</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>children</span> <span class=o>=</span> <span class=n>element</span><span class=o>.</span><span class=n>props</span><span class=o>.</span><span class=n>children</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nb>typeof</span> <span class=n>children</span> <span class=o>===</span> <span class=s1>&#39;string&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>domNode</span><span class=o>.</span><span class=n>textContent</span> <span class=o>=</span> <span class=n>children</span><span class=p>;</span> <span class=o>//</span> <span class=err>文本子节点</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=ne>Array</span><span class=o>.</span><span class=n>isArray</span><span class=p>(</span><span class=n>children</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>children</span><span class=o>.</span><span class=n>forEach</span><span class=p>(</span><span class=n>child</span> <span class=o>=&gt;</span> <span class=n>render</span><span class=p>(</span><span class=n>child</span><span class=p>,</span> <span class=n>domNode</span><span class=p>));</span> <span class=o>//</span> <span class=err>递归处理数组</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>children</span><span class=err>?</span><span class=o>.$$</span><span class=nb>typeof</span> <span class=o>===</span> <span class=n>Symbol</span><span class=o>.</span><span class=k>for</span><span class=p>(</span><span class=s1>&#39;react.element&#39;</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>render</span><span class=p>(</span><span class=n>children</span><span class=p>,</span> <span class=n>domNode</span><span class=p>);</span> <span class=o>//</span> <span class=err>单个子虚拟</span> <span class=n>DOM</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=o>//</span> <span class=mf>4.</span> <span class=err>挂载到容器</span>
</span></span><span class=line><span class=cl>  <span class=n>container</span><span class=o>.</span><span class=n>appendChild</span><span class=p>(</span><span class=n>domNode</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>//</span> <span class=err>使用示例</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=n>element</span> <span class=o>=</span> <span class=n>React</span><span class=o>.</span><span class=n>createElement</span><span class=p>(</span><span class=s1>&#39;div&#39;</span><span class=p>,</span> <span class=p>{</span> <span class=n>className</span><span class=p>:</span> <span class=s1>&#39;box&#39;</span> <span class=p>},</span> <span class=s1>&#39;Hello&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=n>container</span> <span class=o>=</span> <span class=n>document</span><span class=o>.</span><span class=n>getElementById</span><span class=p>(</span><span class=s1>&#39;root&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>render</span><span class=p>(</span><span class=n>element</span><span class=p>,</span> <span class=n>container</span><span class=p>);</span> <span class=o>//</span> <span class=err>最终生成</span> <span class=o>&lt;</span><span class=n>div</span> <span class=k>class</span><span class=o>=</span><span class=s2>&#34;box&#34;</span><span class=o>&gt;</span><span class=n>Hello</span><span class=o>&lt;/</span><span class=n>div</span><span class=o>&gt;</span>
</span></span></code></pre></div><ul><li><p>React.createElement（type<code>、</code>props<code>、</code>&mldr;children）参数介绍</p><ul><li><p><strong><code>type</code></strong>（必填）：元素类型（如 <code>'div'</code>、组件类、函数组件）</p></li><li><p><strong><code>props</code></strong>（可选）：属性对象（如 <code>{ className: 'box' }</code>），可为 <code>null</code> 或省略。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>props参数为空的几种写法
</span></span><span class=line><span class=cl>// 写法1：显式传递（经典写法）：可读性差，不推荐
</span></span><span class=line><span class=cl>React.createElement(&#39;div&#39;,, &#39;Hello&#39;, &#39;World&#39;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// 写法2：传递空对象（明确表示无 props）
</span></span><span class=line><span class=cl>React.createElement(&#39;div&#39;, {}, &#39;Hello&#39;, &#39;World&#39;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// 写法3：直接省略 props（利用参数默认值）
</span></span><span class=line><span class=cl>React.createElement(&#39;div&#39;, undefined, &#39;Hello&#39;, &#39;World&#39;);
</span></span></code></pre></div><p>在第二个参数props为空的情况下，后边的多个children参数仍然会被归集到props里；或者说无论 <code>props</code> 是否为空，<code>children</code> 都会被归集到 <code>props.children</code></p></li><li><p><strong><code>...children</code></strong>（可选）：剩余参数，收集所有子元素（字符串、数字、React 元素、数组等）</p><ul><li>参数多于3个以上的话，会把后边的多个参数收集在一个数组里，始终保持三个参数</li><li><code>children</code> <strong>必须</strong>是 <code>props</code> 的一个属性，而不是与 <code>type</code>/<code>props</code> 平级的字段。</li><li>children都要收集在props里</li></ul></li><li><p>createElement返回的对象数据结构</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>  type: string | Function, // 元素类型（如 &#39;div&#39; 或组件函数）
</span></span><span class=line><span class=cl>  props: Object,          // 所有属性（包括 children）
</span></span><span class=line><span class=cl>  key: string ,
</span></span><span class=line><span class=cl>  ref: Object ,
</span></span><span class=line><span class=cl>  // ...其他内部字段（如 $$typeof 标识）
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div></li></ul></li></ul><h3 id=jsx实践>JSX实践</h3><p><strong>JSX is a powerful syntax extension for JavaScript that enables developers to write UI components with a familiar HTML-like structure while seamlessly integrating dynamic JavaScript logic through embedded expressions (<code>{}</code>).</strong> Unlike traditional templates, JSX compiles to React.createElement() calls, allowing it to leverage the full power of JavaScript for rendering logic, conditional statements, and loops. Its component-centric design promotes reusability and modularity, while automatic escaping of embedded content ensures security against XSS attacks. By blending declarative markup with JavaScript, JSX bridges the gap between design and functionality, making it the cornerstone of React’s efficient, virtual DOM-driven rendering pipeline.</p><h4 id=react如何使用javascript>React如何使用javascript</h4><p>React使用了javascript的大部分模式，但是最大的不同就是使用了jsx语法。JSX扩展了javascript语法，让类HTML代码可以和javascript代码一起工作。比如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=k>const</span> <span class=n>heading</span> <span class=o>=</span> <span class=o>&lt;</span><span class=n>h1</span><span class=o>&gt;</span><span class=n>Mozilla</span> <span class=n>Developer</span> <span class=n>Network</span><span class=o>&lt;/</span><span class=n>h1</span><span class=o>&gt;</span><span class=p>;</span>
</span></span></code></pre></div><p><code>heading</code>常量叫做JSX表达式，React可以在我们的程序中渲染<code>&lt;h1></code>元素，这是单个元素的写法。再看看多个元素嵌套的写法：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=k>const</span> <span class=n>header</span> <span class=o>=</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=o>&lt;</span><span class=n>header</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=n>h1</span><span class=o>&gt;</span><span class=n>Mozilla</span> <span class=n>Developer</span> <span class=n>Network</span><span class=o>&lt;/</span><span class=n>h1</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=o>&lt;/</span><span class=n>header</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span></code></pre></div><p>这里的括号是可选的，是提高代码阅读性加的，但是更推荐这种带括号的写法，避免不必要的错误产生。</p><p>这种写法和HTML标签的写法类似，JSX是HTML和javascript的混合体，只要熟悉HTMl的写法，很快熟悉jsx的写法，轻松直观的编写用户界面。</p><p>浏览器并不能直接识别jsx代码，需要用Babel/Parcel进行编译，最终转换为标准的的javascript代码，如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=k>const</span> <span class=n>header</span> <span class=o>=</span> <span class=n>React</span><span class=o>.</span><span class=n>createElement</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=s2>&#34;header&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>null</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>React</span><span class=o>.</span><span class=n>createElement</span><span class=p>(</span><span class=s2>&#34;h1&#34;</span><span class=p>,</span> <span class=n>null</span><span class=p>,</span> <span class=s2>&#34;Mozilla Developer Network&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span></code></pre></div><p>jsx表达式中的标签都会转换为React.createElement的调用，返回一个javascript对象，结构如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>  type: &#34;header&#34;,
</span></span><span class=line><span class=cl>  props: {
</span></span><span class=line><span class=cl>    children: {
</span></span><span class=line><span class=cl>      type: &#34;h1&#34;,
</span></span><span class=line><span class=cl>      props: { children: &#34;Mozilla Developer Network&#34; }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>这个对象是虚拟 DOM 的最小单位，React 会将这些 React 元素组成的树状结构（虚拟 DOM）与真实的 DOM 进行对比（通过 Diffing 算法），然后高效地更新真实 DOM。虚拟 DOM 本身不是浏览器 DOM，而是一个轻量级的 JavaScript 对象表示。与真实 DOM 的区别：</p><ul><li>真实 DOM 是浏览器提供的 API（如 <code>document.createElement("header")</code> 返回的对象），操作成本较高。</li><li>React 元素（虚拟 DOM）是纯 JS 对象，创建和对比的开销极小。</li></ul><p><strong>通过对jsx表达式的编译，转为对React.createElement（）函数的调用，最终生成的是虚拟的DOM树状结构对象，通过Diffing算法，渲染真实的DOM。</strong></p><h4 id=在jsx中应用变量表达式>在JSX中应用变量、表达式</h4><ul><li><p>在标签的内容部分应用变量和表达式</p><p><code>&lt;h1> content-area&lt;/h1></code></p></li></ul><p>在这里所示的<code>content-area</code>部分使用<code>{}</code>书写变量，会取变量的值进行渲染。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=k>const</span> <span class=n>subject</span> <span class=o>=</span> <span class=s2>&#34;React&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>function</span> <span class=n>App</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=o>//</span> <span class=n>code</span> <span class=n>omitted</span> <span class=k>for</span> <span class=n>brevity</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>//</span><span class=p>{</span><span class=n>subject</span><span class=p>}</span><span class=err>会读取变量</span><span class=n>subject的值</span><span class=err>，最终呈现的是</span><span class=o>&lt;</span><span class=n>h1</span><span class=o>&gt;</span> <span class=n>Hello</span> <span class=p>,</span><span class=n>React</span><span class=o>&lt;/</span><span class=n>h1</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=n>h1</span><span class=o>&gt;</span><span class=n>Hello</span><span class=p>,</span> <span class=p>{</span><span class=n>subject</span><span class=p>}</span><span class=o>&lt;/</span><span class=n>h1</span><span class=o>&gt;</span>
</span></span></code></pre></div><ul><li><p>props（在标签的属性部分书写属性和值）</p><p>props是jsx中在组件之间传递数据的一种方式。书写方式和HTML标签中的属性和值的写法相同。两者的不同之处在于传递数据的对象不同，HTML标签中的属性和值的写法是给HTML element传递数据，而jsx中的props是在组件之间传递数据，通常是父组件给子组件传递数据。比如`prop=&ldquo;value&rdquo;。</p><p>打开项目程序<code>/src/main.jsx</code>，在主程序中加入下面的jsx元素</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>
</span></span><span class=line><span class=cl>&lt;App subject=&#34;Clarice&#34; /&gt;
</span></span></code></pre></div><p>这样的写法，是在main.jsx程序中调用App组件，并以<code>prop=value</code>的形式给App组件传递数据,这里是<code>subject="Clarice"</code>。</p><p>接下来就要在App组件中给App函数添加接收数据的props参数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>function App(props) {
</span></span><span class=line><span class=cl>  return (
</span></span><span class=line><span class=cl>    &lt;&gt;
</span></span><span class=line><span class=cl>      &lt;header&gt;
</span></span><span class=line><span class=cl>        &lt;h1&gt;Hello, {props.subject}!&lt;/h1&gt;
</span></span><span class=line><span class=cl>        &lt;button type=&#34;button&#34; className=&#34;primary&#34;&gt;
</span></span><span class=line><span class=cl>          Click me!
</span></span><span class=line><span class=cl>        &lt;/button&gt;
</span></span><span class=line><span class=cl>      &lt;/header&gt;
</span></span><span class=line><span class=cl>    &lt;/&gt;
</span></span><span class=line><span class=cl>  );
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>props在React中是以javascript对象的形式保存数据的，通过标签书写形式（其中的props则是类似属性和值的写法）完成父组件对子组件的调用，数据是通过props对象传递给子组件的函数参数。</p><p>**简单理解JSX的基本思想：把XML-HTML类的标签语言引入到javascript，把这些标签组成的UI作为变量、表达式这些可编程元素来构建动态UI。所谓的动态是让标签的内容部分和属性部分引用javascript变量、表达式、函数，真正实现了动态的标签。**这就是javascript和html的相互融合。而要理解React组价的核心，主要是component、props、state。要通过实例慢慢熟悉这些设计思想，只有充分理解了这些设计思想，才能真正掌握这些技术。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1. 模块调用标签化  &lt;App      /&gt;的写法
</span></span><span class=line><span class=cl>2. 函数返回标签化   return( &lt;&gt; )
</span></span><span class=line><span class=cl>3. 数据传递标签  各种props的扩展
</span></span></code></pre></div></li></ul><h3 id=react--component>React Component</h3><p>[ ] todolist</p><p><strong>Componentizing the app</strong></p><p>components are either obvious pieces of UI, reused pieces of UI</p><p>这句话多看几遍：在React todo App的【React events and state】部分</p><p>Instead, we can write a function in <code>&lt;App /></code> that will expect some data from our form as an input, then pass that function to <code>&lt;Form /></code> as a prop. This function-as-a-prop is called a <strong>callback prop</strong>. Once we have our callback prop, we can call it inside <code>&lt;Form /></code> to send the right data to <code>&lt;App /></code>.</p><h3 id=jsx中的注意事项>jsx中的注意事项</h3><h4 id=几个特别的属性>几个特别的属性</h4><ul><li><p>className</p></li><li><p>htmlfor</p></li><li><p>boolean atribution</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Because JSX is JavaScript, there&#39;s a gotcha to be aware of with boolean attributes: writing defaultChecked=&#34;false&#34; will set a string value of &#34;false&#34; rather than a boolean value. Non-empty strings are truthy, so React will consider defaultChecked to be true and check the checkbox by default. This is not what we want, so we should avoid it.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>If you&#39;d like, you can practice writing boolean attributes with another attribute you may have seen before, hidden, which prevents elements from being rendered on the page. Try adding hidden to the &lt;h1&gt; element in App.jsx to see what happens, then try explicitly setting its value to {false}. Note, again, that writing hidden=&#34;false&#34; results in a truthy value so the &lt;h1&gt; will hide. Don&#39;t forget to remove this code when you&#39;re done.
</span></span></code></pre></div><p>比如说hidder=&ldquo;false&rdquo;,在javascript中，布尔值有true 和false。其他值可以通过是否为空来判断，非空为真值。所以及时hidden=“false”，以为"false"是一个字符串，非空，所以最终还是hidden = true ,偏离了本意。</p></li></ul><h4 id=reuse--of--component>reuse of component</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Make a unique &lt;Todo /&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Components are powerful because they let us re-use pieces of our UI, and refer to one place for the source of that UI. The problem is, we don&#39;t typically want to reuse all of each component; we want to reuse most parts, and change small pieces. This is where props come in.
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>What&#39;s in a name?
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>In order to track the names of tasks we want to complete, we should ensure that each &lt;Todo /&gt; component renders a unique name.
</span></span><span class=line><span class=cl>In App.jsx, give each &lt;Todo /&gt; a name prop. Let&#39;s use the names of our tasks that we had before:
</span></span><span class=line><span class=cl>jsx
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>&lt;ul
</span></span><span class=line><span class=cl>  role=&#34;list&#34;
</span></span><span class=line><span class=cl>  className=&#34;todo-list stack-large stack-exception&#34;
</span></span><span class=line><span class=cl>  aria-labelledby=&#34;list-heading&#34;&gt;
</span></span><span class=line><span class=cl>  &lt;Todo name=&#34;Eat&#34; /&gt;
</span></span><span class=line><span class=cl>  &lt;Todo name=&#34;Sleep&#34; /&gt;
</span></span><span class=line><span class=cl>  &lt;Todo name=&#34;Repeat&#34; /&gt;
</span></span><span class=line><span class=cl>&lt;/ul&gt;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Once again, we want to reuse most of the UI that makes up a &lt;Todo /&gt; component, but change one thing. That&#39;s a good job for another prop
</span></span></code></pre></div><p>整体的思路，在复用一个组件时要修改UI的一部分，重复利用props来给子组件传递参数，来定制jsx element的显示或者行为：<strong>通过传递props来动态设置jsx元素</strong>。</p><p>下面这段文档是React官网对component概念的解释。</p><p>Creating and nesting components</p><p>React apps are made out of <em>components</em>. A component is a piece of the UI (user interface) that has its own logic and appearance. A component can be as small as a button, or as large as an entire page.</p><p>React components are JavaScript functions that return markup:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>function MyButton() {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  return (
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    &lt;button&gt;I&#39;m a button&lt;/button&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  );
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>Now that you’ve declared <code>MyButton</code>, you can nest it into another component:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=k>export</span> <span class=n>default</span> <span class=n>function</span> <span class=n>MyApp</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=n>div</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=n>h1</span><span class=o>&gt;</span><span class=n>Welcome</span> <span class=n>to</span> <span class=n>my</span> <span class=n>app</span><span class=o>&lt;/</span><span class=n>h1</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=n>MyButton</span> <span class=o>/&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>&lt;/</span><span class=n>div</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Notice that <code>&lt;MyButton /></code> starts with a capital letter. That’s how you know it’s a React component. React component names must always start with a capital letter, while HTML tags must be lowercase.</p><h3 id=react的state管理todo-list>React的state管理（todo-list）</h3><ul><li><input disabled type=checkbox> useSate概念</li></ul><h3 id=nextjs>Next.js</h3><p>react 是一个基于视图层的实现组件复用的javascript库，如果想要一个全功能的框架，还要继续学习Next.js。其他的框架就暂时不看了，根本学不完（^-^）。</p><h3 id=react-bootstrap>React bootStrap</h3><h4 id=react-bootstrap-是什么><strong>React Bootstrap 是什么</strong></h4><ul><li><strong>定义</strong>：React Bootstrap 是 <strong>Bootstrap 框架的 React 实现版本</strong>，将 Bootstrap 的 CSS 样式与 React 的声明式组件深度结合，提供开箱即用的 UI 组件（如按钮、表单、导航栏等）。</li><li><strong>特点</strong>：<ul><li><strong>不依赖 jQuery</strong>：完全用 React 重构 Bootstrap 的交互逻辑，避免传统 Bootstrap 对 jQuery 的依赖。</li><li><strong>组件化开发</strong>：通过 React 组件（如 <code>&lt;Button></code>、<code>&lt;Navbar></code>）封装 Bootstrap 的 HTML 结构，简化 DOM 操作。</li><li><strong>响应式设计</strong>：内置 Bootstrap 的网格系统和媒体查询，确保界面自适应不同设备。</li></ul></li></ul><h4 id=如何使用-react-bootstrap><strong>如何使用 React Bootstrap</strong></h4><p><strong>1. 安装依赖</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1>#bash</span>
</span></span><span class=line><span class=cl>npm install react-bootstrap bootstrap 
</span></span><span class=line><span class=cl><span class=c1># 或 </span>
</span></span><span class=line><span class=cl>yarn add react-bootstrap bootstrap
</span></span></code></pre></div><ul><li><strong><code>react-bootstrap</code></strong>：React 组件库。</li><li><strong><code>bootstrap</code></strong>：提供 CSS 样式文件（必需）。</li></ul><p><strong>2. 导入组件</strong></p><ul><li><p><strong>按需导入</strong>（推荐）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-jsx data-lang=jsx><span class=line><span class=cl><span class=kr>import</span> <span class=p>{</span> <span class=nx>Button</span><span class=p>,</span> <span class=nx>Form</span> <span class=p>}</span> <span class=nx>from</span> <span class=s1>&#39;react-bootstrap&#39;</span><span class=p>;</span>
</span></span></code></pre></div></li><li><p>避免全量导入，减少打包体积。</p></li></ul><p><strong>3. 使用组件</strong></p><ul><li><p><strong>JSX 中调用</strong>（首字母大写）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>function</span> <span class=n>MyApp</span><span class=p>()</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>(</span> 
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=ne>Button</span> <span class=n>variant</span><span class=o>=</span><span class=s2>&#34;primary&#34;</span><span class=o>&gt;</span><span class=n>Click</span> <span class=n>Me</span><span class=o>&lt;/</span><span class=ne>Button</span><span class=o>&gt;</span> 
</span></span><span class=line><span class=cl>    <span class=o>&lt;</span><span class=n>Form</span><span class=o>&gt;</span> 
</span></span><span class=line><span class=cl>      <span class=o>&lt;</span><span class=n>Form</span><span class=o>.</span><span class=n>Control</span> <span class=n>type</span><span class=o>=</span><span class=s2>&#34;text&#34;</span> <span class=n>placeholder</span><span class=o>=</span><span class=s2>&#34;Input&#34;</span> <span class=o>/&gt;</span> 
</span></span><span class=line><span class=cl>    <span class=o>&lt;/</span><span class=n>Form</span><span class=o>&gt;</span> 
</span></span><span class=line><span class=cl>  <span class=p>);</span> 
</span></span></code></pre></div><p><strong><code>variant</code></strong>：替代传统 Bootstrap 的 <code>class</code>（如 <code>btn-primary</code>），通过属性控制样式。</p><p>注意首字母大写的标签是来自react-bootstrap的元素，如果是小写的标签元素，就是html原生的标签。</p></li></ul><p><strong>4. 引入 CSS</strong></p><ul><li><p>在项目入口文件（如 <code>src/index.js</code>）中全局引入：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>   import &#39;bootstrap/dist/css/bootstrap.min.css&#39;;
</span></span></code></pre></div></li></ul><p>更多的组件和使用可以参考<a href=https://react-bootstrap.github.io/>react bootstrap官网</a></p><h3 id=关于react整体思路的总结>关于React整体思路的总结：</h3><p>1、通过组件实现模块化，每个组件只作一件事，如果有重复那就把它独立出去作为一个单独的组件，然后在spa总应用程序里调用这个组件。</p><p>2、component就是一个javascript函数，在函数里完成变量、表达式、函数的加工，最终要返回一个jsx元素，也就是返回一个html的UI，这个jsx元素可以小到一个按钮、编辑框，大到一个窗体、页面。</p><p>3、在总的App里完成多个组件的组装，实现期望的html页面布局，把这个App保存为一个.js文件</p><p>4、组件之间通过标签式的写法（首字母大写的组件名作为标签）实现调用，并通过props作为参数传递数据。</p><p>5、在站点的inde.html里通过<code>&lt;script src="xxx.js">&lt;/script>></code>来调用这个javascrip的App文件，当用户通过浏览器打开index.html时，会把这个.js文件下载到本地的缓存，然后这个程序就是web应用的启动点</p><p>以后 有时间和兴趣的化再深入学习和实践</p></div></article></div><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll("pre code").forEach(e=>{hljs.highlightElement(e);const t=document.createElement("button");t.className="copy-code",t.textContent="Copy",t.addEventListener("click",()=>{navigator.clipboard.writeText(e.textContent).then(()=>{t.textContent="Copied!",t.classList.add("copied"),setTimeout(()=>{t.textContent="Copy",t.classList.remove("copied")},2e3)})}),e.parentElement.prepend(t)});const o=document.querySelectorAll(".article-content h2[id], .article-content h3[id]"),i=document.querySelectorAll('.toc a[href^="#"]'),a=document.querySelector(".top-nav").offsetHeight,n=document.querySelector(".toc-container"),e=[];o.forEach(t=>{e.push({id:t.id,top:t.offsetTop-a-20})});function s(){const s=window.scrollY;let t="";for(let n=e.length-1;n>=0;n--)if(e[n].top<=s+50){t=e[n].id;break}i.forEach(e=>{const s=e.getAttribute("href")===`#${t}`;if(e.classList.toggle("active",s),s){const t=e.offsetTop-n.clientHeight/2;n.scrollTop=t}})}let t=!1;window.addEventListener("scroll",()=>{t||(window.requestAnimationFrame(()=>{s(),t=!1}),t=!0)}),s()})</script></body></html>