<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Learning The Unix Operating System | 技术博客</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css><link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&display=swap" rel=stylesheet><style>:root{--nav-height:60px;--toc-width:280px;--content-padding:40px;--primary-color:#3498db;--text-color:#333;--light-gray:#f5f5f5;--border-color:#eaeaea}*{box-sizing:border-box;margin:0;padding:0}body{font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,sans-serif;color:var(--text-color);line-height:1.6;padding-top:var(--nav-height);overflow-x:hidden}.top-nav{position:fixed;top:0;left:0;right:0;height:var(--nav-height);background:#fff;box-shadow:0 2px 10px rgba(0,0,0,.1);display:flex;align-items:center;padding:0 30px;z-index:1000}.nav-container{width:100%;max-width:1400px;margin:0 auto;display:flex;justify-content:space-between;align-items:center}.site-title{font-size:1.4rem;font-weight:700;color:var(--primary-color);text-decoration:none}.nav-links{display:flex;gap:25px}.nav-links a{color:var(--text-color);text-decoration:none;font-size:1rem;transition:color .3s}.nav-links a:hover{color:var(--primary-color)}.main-container{display:flex;max-width:1400px;margin:0 auto;padding:20px}.toc-container{position:sticky;top:calc(var(--nav-height) + 20px);align-self:flex-start;width:var(--toc-width);padding:20px;margin-right:30px;max-height:calc(100vh - var(--nav-height) - 40px);overflow-y:auto;background:var(--light-gray);border-radius:8px;scroll-behavior:auto;overscroll-behavior:contain}.toc-title{font-size:1.2rem;margin-bottom:15px;padding-bottom:10px;border-bottom:2px solid var(--primary-color)}.toc ul{list-style:none;padding-left:15px}.toc li{margin-bottom:8px;position:relative}.toc a{color:var(--text-color);text-decoration:none;display:block;padding:5px 0 5px 10px;transition:all .2s;font-size:.95rem;border-left:2px solid transparent}.toc a:hover{color:var(--primary-color);transform:translateX(5px)}.toc a.active{color:var(--primary-color);font-weight:700;border-left:3px solid var(--primary-color);background:rgba(52,152,219,5%);transform:translateX(5px)}.content-container{flex:1;background:#fff;padding:var(--content-padding);border-radius:8px;box-shadow:0 2px 15px rgba(0,0,0,5%)}.article-header{margin-bottom:30px;border-bottom:1px solid var(--border-color);padding-bottom:20px}.article-title{font-size:2rem;margin-bottom:10px;color:#2c3e50}.article-meta{display:flex;gap:20px;color:#7f8c8d;font-size:.9rem;margin-bottom:15px}.article-content{line-height:1.8}.article-content h2{font-size:1.6rem;margin:2rem 0 1rem;padding-bottom:.5rem;border-bottom:1px solid var(--border-color);scroll-margin-top:calc(var(--nav-height) + 20px)}.article-content h3{font-size:1.3rem;margin:1.5rem 0 .8rem;scroll-margin-top:calc(var(--nav-height) + 20px)}.article-content img{max-width:100%;height:auto;border-radius:6px;margin:1.5rem 0;box-shadow:0 3px 10px rgba(0,0,0,.1)}.article-content pre{position:relative;background:#f7f7f7;color:#242424;border-left:4px solid #04b04f;border-radius:8px;padding:1.5rem 1rem 1rem;margin:1.5rem 0;overflow:auto;box-shadow:0 1px 3px rgba(0,0,0,.1);max-height:40vh;white-space:pre-wrap;font-family:fira code,Menlo,Monaco,Consolas,monospace;font-size:.9rem;line-height:1.5;scrollbar-width:thin;scrollbar-color:#c4c4c4 #f7f7f7}.article-content code{font-family:inherit;color:inherit!important;background:0 0!important;padding:0;text-shadow:none!important;font-size:.9rem}.hljs-meta,.hljs-built_in{color:#04b04f}.hljs-attribute{color:#e91e63}.hljs-string{color:#2e7d32}.hljs-number{color:#2196f3}.article-content pre::-webkit-scrollbar{width:12px;height:12px}.article-content pre::-webkit-scrollbar{width:12px;height:12px}.article-content pre::-webkit-scrollbar-thumb{background:#04b04f;opacity:.6;border:3px solid #f7f7f7}.article-content pre::-webkit-scrollbar-track{background:#f7f7f7;border-radius:6px}.copy-code{position:absolute;top:10px;right:15px;background:rgba(0,0,0,.1);border:1px solid rgba(0,0,0,.2);color:#242424;border-radius:4px;padding:3px 8px;font-size:.8rem;cursor:pointer;transition:all .3s;opacity:0;z-index:10}pre:hover .copy-code{opacity:1}.copy-code:hover{background:rgba(0,0,0,.2)}.copy-code.copied{background:#28a745;color:#fff;border-color:#28a745}@media(max-width:1024px){.toc-container{width:240px;padding:15px}.content-container{padding:25px}}@media(max-width:768px){.main-container{flex-direction:column}.toc-container{position:static;width:100%;margin-right:0;margin-bottom:30px;max-height:none}.article-title{font-size:1.8rem}.article-content pre{max-height:50vh;padding-right:10px}}</style></head><body><nav class=top-nav><div class=nav-container><a href=/ class=site-title>技术博客</a><div class=nav-links><a href=/>首页</a>
<a href=/posts/>所有文章</a>
<a href=/categories/>分类</a>
<a href=/tags/>标签</a></div></div></nav><div class=main-container><aside class=toc-container><h3 class=toc-title>目录</h3><div class=toc><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#learning--the-unix-operating-system>Learning The Unix Operating System</a></li></ul></li></ul></li></ul></nav></div></aside><article class=content-container><header class=article-header><h1 class=article-title>Learning The Unix Operating System</h1><div class=article-meta><span>📅 2024年4月29日</span></div></header><div class=article-content><h4 id=learning--the-unix-operating-system>Learning The Unix Operating System</h4><h5 id=unix的简要发展历程>Unix的简要发展历程</h5><p>1964年，美国电话电报公司（AT&amp;T）、通用电器公司（GE）及麻省理工学院（MIT）合作，提出了一个超级分时操作系统的开发计划。这个计划，被命名为Multics OS。Multics是“MULTiplexed Information and Coputing System（多路信息与计算系统）”的意思。借助这套系统，打造一台能够连接1000台终端、满足300人同时在线的计算机，项目持续了5年没有达到预期的目的，率属于AT&amp;T的贝尔实验室宣布退出该计划。</p><p>贝尔实验室退出之后，相关的项目组成员就闲了下来。其中就有一个人，名字叫做肯·汤普森（Ken Thompson）肯·汤普森此前在Multics上开发了一款名叫"星际旅行（Space Travel）" 的游戏。退出Multics项目后，肯·汤普森就没办法继续玩这个游戏了。他打算在一台空闲的PDP-7（DEC公司生产的一种小型计算机，性能很低）上，开发一个简单操作系统，运行这个游戏。肯·汤普森趁着妻子回家探亲，用了1个月的时间，使用汇编语言，写出了一个简版的Multics系统（包括一组内核程序，一些内核工具程序，以及一个小的文件系统）。实验室的同事们，将这个系统戏称为Unics。Uni作为前缀，是“单一、一个”的意思。Unics，对应Multics，是“单路信息与计算系统”的意思。后来，大家又取其谐音，直接称其为**“Unix”**。</p><p>基于汇编语言编写的Unics，硬件通用性差，无法移植到其它机器上运行。因此，肯·汤普森尝试使用BCPL、PASCAL语言进行重写。但是，效果并不理想。这时，他的同事<strong>丹尼斯.里奇</strong>（Dennis Ritchie）站了出来。丹尼斯.里奇在BCPL语言（也就是B语言）的基础上，开发了一套新的语言，也就是后来如日中天的<strong>C语言</strong>（按字母表顺序，B之后就是C）。不久后，丹尼斯.里奇用C语言重写Unics成功。就这样，Unix操作系统正式诞生了。1973年，丹尼斯·里奇和肯·汤普森正式发表论文，宣布了Unix的存在。消息引起很大反响，很多人都期望学习和研究Unix。贝尔实验室（AT&amp;T）推出了Unix之后，因为受美国政府反垄断制裁的原因，并不能对它进行销售。所以，他们只能将Unix无偿提供给所有人学习。又过了一段时间，AT&amp;T发布了Unix系统第5版，并授权给教育机构使用。1975年，他们第一次以2万美元的价格，授权企业使用Unix第6版。这期间，很多企业和机构开始打Unix的主意。1977年，伯克利大学的研究生比尔·乔伊（Bill Joy），将Unix程序整理到磁带上，推出了BSD版本。BSD，就是Berkeley Software Distribution（伯克利软件发行版）。1978年，SCO（一家服务器系统软件供应商）包装发行了商用版的Unix。目前公认的最完美版本，是1979年发行的System V7。这个版本也被Unix玩家们称为“最后一个真正的UNIX”。1980年，美国国防高级研究计划局（DARPA）准备制定TCP/IP协议，选择了与BSD合作。这大大促进了Unix的发展和普及。</p><h6 id=unix的主要两个分支>Unix的主要两个分支</h6><p>基于AT&amp;T的System V商用版本Unix和基于BSD的开源版本Unix。商业版本包括SunOS、Solaris、SCO Unix、AIX、HP/UX和 ULTRIX 等，开源版本包括FreeBSD、NetBSD、Linux等。</p><h5 id=getting--start>Getting Start</h5><p>通过系统管理员分配的账号，连接到本地或者远程的计算机。</p><ul><li><p>本地登录。启动计算机，等待终端屏幕显示<code>login:</code>信息后，输入正确的用户名[回车]和密码[回车]后可登录，显示shell的提示符，比如<code>%</code>或者<code>$</code>(shell的提示符可以自定义)。如果输入的用户名或者密码错误，无法通过删除键来修改，只需再次按下回车键，在shell提示符重新出现后，重新输入正确的用户名和密码。在输入密码时屏幕并不会显示你输入的字符。</p></li><li><p>远程登陆。</p><p>在登录本地终端之后，可以运行telnet、rlogin（通过网路登录远程主机）,远程登录程序格式如下：</p><blockquote><p><em>program-name remote-hostname</em></p></blockquote></li></ul><p>​ 登录远程主机后，会在shell的提示符前显示登陆的主机名称，比如：<code>hostname%</code></p><ul><li><p>输入的几个简单的shell comand （这里的shell提示符为%）</p><blockquote><p>% date</p></blockquote><blockquote><p>% who</p></blockquote><blockquote><p>% who am i</p></blockquote></li><li><p>更正错误的命令行输入</p><ul><li>删除光标左边的内容：Backspace、ctrl+h</li><li>删除光标右边的内容: delete</li><li>删除整行的命令行内容: ctrl+u</li></ul></li><li><p>常见的控制符号</p><ul><li>中断或者取消命令的执行：<strong>ctrl+c</strong> 或者del键</li><li>ctrl+z 可以把当前的shell暂停到后台，弹出一个新的shell （这个需要后期安装好netbsd之后实践一下）</li><li>暂停程序输出在屏幕：ctrl+s</li><li>继续显示由ctrl+s暂停的屏幕输出：ctrl+q</li><li>从程序出退出：<strong>ctrl+d</strong><ul><li>在当前的shell提示符下ctrl+d就退出shell</li><li>在cat、mail程序中输入ctrl+d退出这些程序，返回到shell</li><li>exit</li></ul></li></ul></li><li><p>logout</p><p>在关闭计算机及电源之前，必须要退出登录的终端。根据不同的shell，可以尝试下边三种logout的命令。</p><ul><li>exit</li><li>logout</li><li>ctrl+d</li></ul></li></ul><p>​ 如果是在本地机器登录的终端，logou之后会重新显示login；如果在本地机器使用gnome、kde等窗口系统，关闭窗口系统；如果是登录在远程计算机，logout之后，会显示本地机器的shell，可以继续使用退出终端命令，直到login出现。</p><ul><li><p>unix命令的基本语法和一般规则</p><blockquote><p>command option(s) filename(s)</p></blockquote><ul><li>命令大多为小写</li><li>options一般为单个字母，用<code>-</code>作为前缀，多个options之间用空格分开</li><li>多个options可以合并在一起，比如<code>ls -a -l</code> 可以写为<code>ls -al</code></li><li>一些命令可以包含长格式的options，比如<code>--delete</code></li><li>Options 要写在filename前面</li><li>在一个命令行里可以写多条命令，不同的命令之间用分号分隔。</li><li>除了shell下输入的command 之外，还有以下command拥有自己专属的命令。比如more、pg、mail，vi、emacs等，在启动这些程序之后，会显示他们自己的命令提示符。比如，如果进入了mail,会看到一个mail的命令提示符，你可以输入这些命令来处理邮件信息。当输入<code>q</code>时，退出mail，重新又来到shell的提示符下，可以继续输入其他的shell command 。</li></ul></li><li><p>没有响应的终端</p><p>因为等待连接或者计算机后台正在处理的进程多，需要的资源没有到位等原因，一个unix的session可能会暂时没有响应。可以使用以下几种操作来处理：</p><ul><li>也许时在输入了command之后忘记了回车，此时敲个回车试试</li><li>输入命令并回车后依然没有反应，输入ctrl+j来reset你的终端。如果还是不起作用，就需要logout你的终端(exit、logout、ctrl+d试试)，然后关闭终端。</li><li>如果你的shell支持job control，试试ctrl+z，这会暂停这个程序，并返回一个新的shell 提示符，利用jobs命令显示正在运行中的进程，然后使用fg命令把那个暂停的程序带到前台运行，或者使用kill命令终止那个暂停的程序。</li><li>使用delete键或者ctrl+c键来中断正在运行的程序。如果不起作用，就再按一次。如果还是不起作用，超过两次以上的中断按键不会起作用，只能用别的办法了。</li><li>如果是由按下ctrl+s引起的暂停，再试试按下ctrl+q</li><li>如果你正在使用类似mail的程序，试试ctrl+d这个手段来终止程序，返回到shell 提示符。</li></ul></li></ul><h5 id=在unix中使用window>在Unix中使用window</h5><p>当前的Unix系统支持多种类型的Window系统，比如gnome,kde等。使用Window 系统，可以在一个unix终端一次处理多个session。对于Linux用户来说，可以使用Alt+F1、Alt+F2一直到Alt+F8来开启八个虚拟控制台，每一个虚拟控制台都是一个带有shell提示符的Unix Session。可以在任意一个虚拟控台里独立输入command，在完成任务后，要记得从每个开启的虚拟控制台中logout。Unix中的X window是由Window Manager管理的，常见的管理器有mwm, fvwm, twm。</p><ul><li><p>在shell提示符下运行xinit来打开X Window。具体命令要参考自己使用系统的文档，比如有的系统可能是startsx命令。</p></li><li><p>运行Window Manager。有的系统在使用xinit等命令启动窗口系统时会自动运行window manager 。可以观察以下打开的窗口是否有边框，是否有标题，是否有控制盒子，如果没有这些元素，说明没有启动window manager 。或者鼠标在窗口的空白处单击，如果没有弹出菜单，也说明没有启动window manager ，需要手动运行命令启动window manager 。</p><blockquote><p>mwm &</p></blockquote><blockquote><p>twm &</p></blockquote><blockquote><p>olwm &</p></blockquote><blockquote><p>具体的名称根据自己使用的X window的window manager名称来决定。</p></blockquote></li><li><p><strong>xterm</strong> window</p></li></ul><p>作为一个最重要的window，<strong>xterm</strong> makes a terminal emulator window with a UNIX login session inside, just like a miniature terminal. 可以在一个打开的xterm窗口使用xterm打开新的客户端，最好在第一个打开的窗口里开启新的客户端，如果shell自带job control的话，就可以很容易控制所有开启的客户端。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Here are a few of the X client programs that your system may have:
</span></span><span class=line><span class=cl>resize: helps programs in xterm windows recognize new window size
</span></span><span class=line><span class=cl>xbiff: tells you when new electronic mail comes in
</span></span><span class=line><span class=cl>xclipboard: helps with copying and pasting text
</span></span><span class=line><span class=cl>xdpr: prints a window (with the printer)
</span></span><span class=line><span class=cl>xedit: simple text editor
</span></span><span class=line><span class=cl>xmag: magnifies parts of the screen
</span></span><span class=line><span class=cl>xman: browses UNIX manual (reference) pages
</span></span><span class=line><span class=cl>xmh: electronic mail program
</span></span><span class=line><span class=cl>xset: sets user preferences
</span></span></code></pre></div><ul><li><p>退出X window
关闭X window的关键是弄清楚谁是那个控制程序，当退出控制程序的时候，其他剩下的X-based程序都会被终止。控制程序通常是那个window manager，或者是第一个启动其他客户端的xterm window。控制程序是xterm,建议把第一个xterm window最小化，在关闭完其他客户端window之后再关闭启动其他客户端的xterm ，这样就不会因为不注意关闭了xterm window，导致过早终止会话。</p><ul><li>要退出window manager,选择root menu的Exit菜单项或者Quit菜单项。</li><li>如果控制程序是xterm，则先在各个客户程序window中使用可出程序自己的退出命令，结束程序的运行，然后返回到xterm窗口，在xterm的shell提示符下使用exit关闭该xterm window。最后再关闭那个启动其他X clent program的xterm window。</li></ul></li></ul><h5 id=unix-用户账户>Unix 用户账户</h5><p>作为一个认证账户，登录Unix系统后，就可以享用系统提供三项功能：</p><ul><li><p>一个主目录来保存自己的文件</p></li><li><p>一个用户名，用来标识用户自己，可以从其他用户接收信息，并控制其他用户对自己账户下文件的访问。</p></li><li><p>可以自定义喜欢的操作环境</p></li></ul><h6 id=unix文件系统>Unix文件系统</h6><p>在Unix系统中，一切都是文件，文件系统组织为倒置的树形目录结构。</p><ul><li><p>用户的主目录</p><p>用户登录后，主目录就是自己的工作目录。你可以改变到其他目录，那么改变后的目录就是你的工作目录。也即是说，当前目录就是你的工作目录。</p></li><li><p>Unix目录组织结构</p><p><img alt=img loading=lazy src=/posts/2024/learning-the-unix-operating-system/images/Files_in_the_directory_tree.png></p></li></ul><p><em>root directory</em> and is written as a forward slash ( / )，<em>bin</em>, <em>etc</em>, <em>users</em>, <em>tmp</em>, and <em>usr</em> are some of the <em>subdirectories</em>。These are fairly standard directories and usually contain specific kinds of system files. For instance, <em>bin</em> contains many UNIX commands. Not all systems have a directory named <em>users</em>; it may be called <em>u</em>,<em>home</em>, and/or be located in some other part of the filesystem。</p><ul><li><p>绝对路径</p></li><li><p>相对路径</p></li><li><p>目录和文件操作的几个简单命令</p><ul><li><p>pwd</p></li><li><p>cd</p></li><li><p>ls</p><blockquote><p>% cd /users/carol</p><p>% pwd</p><p>/users/carol</p><p>% cd work</p><p>% pwd</p><p>/users/carol/work</p><p>%</p></blockquote><blockquote><p>ls -al</p></blockquote></li></ul></li></ul><p>​ <img alt=img loading=lazy src=/posts/2024/learning-the-unix-operating-system/images/ls_al.png></p><blockquote><p>The long format provides the following information about each file:</p><p><em>Total n</em></p><p><em>n</em> amount of storage used by the files in this directory.</p><p><em>Type</em></p><p>Tells whether the file is a directory ( d ) or a plain file (-). (There are other less common types</p><p>that we don&rsquo;t explain here.)</p><p><em>Access modes</em></p><p>Specifies three types of users (yourself, your group, all others) who are allowed to read ( r ),</p><p>write ( w ), or execute ( x ) your files.</p><p><em>Links</em></p><p>The number of files and directories linked to this one.</p><p><em>Owner</em></p><p>The person who created or owns the file.</p><p>% ls -a</p><p>. .exrc ch1 ch2 intro</p><p>.. .profile ch10 ch3</p><p>%<em>Group</em></p><p>The group that owns the file. (If your version of UNIX doesn&rsquo;t show this column, add the <strong>-g</strong></p><p>option to see it.)</p><p><em>Size (in bytes)</em></p><p>The size of the file.</p><p><em>Modification date</em></p><p>The date when the file was last modified.</p><p><em>Name</em></p><p>The name of the file or directory.</p></blockquote><p>访问权限列有10位字符，第一个字符代表是目录或者文件，<code>d</code>代表目录，<code>-</code>短横线代表文件。第2-4位代表owner对文件的访问权限，一般是rwx；第5-7位代表组权限，第8-10代表other users的访问权限。</p><p>对于文件的访问权限来讲，r代表读取，w代表改写，x代表可执行。对于文件的x权限，仅仅限于可执行文件。</p><p>对于目录，<code>r</code>权限意味着可以列出该目录下的文件和子目录；<code>w</code>权限意味着可以向目录新建、删除、修改内容；<code>x</code>权限意味着可以访问目录，比如可是用<code>cd</code>命令切换到该目录。一般可以把<code>rx</code>权限同时开放给目录，方便各种操作。如果仅有<code>r</code>权限而没有<code>x</code>权限，就无法进入到该目录中。</p><ul><li><p>chmod</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># to do list:
</span></span></code></pre></div></li><li><p><code>ls -F</code></p></li></ul><p>If you need to know only which files are directories and which are executable files, you can use the <strong>-F</strong> option.If you give the pathname to a directory, <strong>ls</strong> will list the directory but it will <em>not</em> change your working directory. The <strong>pwd</strong> command in the following example shows that:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>% ls -F /users/andy
</span></span><span class=line><span class=cl>calendar goals ideas/
</span></span><span class=line><span class=cl>ch2 guide/ testpgm*
</span></span><span class=line><span class=cl>% pwd
</span></span><span class=line><span class=cl>/etc
</span></span><span class=line><span class=cl>%
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>ls -F puts a / (slash) at the end of each directory name. (The directory name doesn&#39;t really have a
</span></span><span class=line><span class=cl>slash in it; that&#39;s just the shortcut ls -F uses with a directory.) In our example, guide and ideas are
</span></span><span class=line><span class=cl>directories. You can verify this by using ls -l and noting the &#34;d&#34; in the first field of the output. Files
</span></span><span class=line><span class=cl>with an execute status ( x ), like programs, are marked with an * (asterisk). The file testpgm is an
</span></span><span class=line><span class=cl>executable file. Files that aren&#39;t marked are not executable.
</span></span></code></pre></div><h5 id=查看文件的内容>查看文件的内容</h5><h6 id=三个查看文件内容的命令catmorepg>三个查看文件内容的命令：cat、more、pg</h6><ul><li><p>cat (concatnate) 可以把几个小文件连在一起成为一个大文件，也可以把一个文件的内容显示在屏幕上。</p><p>该命令适合一屏可显示的文件，如果一个文件内容过长，一屏显示不下，显示时的滚屏速度超过你阅读的速度，而你又不能往前回看（除非你使用有滚动条的xterm window来显示）。如果你输入了没有提供文件名参数的cat命令，实际上cat会从标准输入(键盘)上读取内容，你可以通过一个回车键，再输入一个ctrl+d告诉cat输入已经结束，离开等待输入的状态。参数filename作为cat命令的输入（standard input），cat把输出显示在屏幕上(standard output)。</p></li><li><p>more 文件内容较长的话，使用cat不合适，可以使用more来显示</p><p>more后边跟随的filename作为输入，more把输出显示在屏幕上，最屏幕的最下方显示一个光标和提示符，可以在这里输入more自己的命令，用来告诉more进行哪种操作。比如输入<code>h</code>,显示more的帮助信息；输入<code>nf</code>可以向前移动<code>n</code>页；输入<code>b</code>可以向后翻一页；具体命令见下面的表格：</p><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td>[SPACE]</td><td>Display next page.</td></tr><tr><td>[RETURN]</td><td>Display next line.</td></tr><tr><td><em>n</em>f</td><td>Move forward <em>n</em> pages.</td></tr><tr><td>b</td><td>Move backward one page.</td></tr><tr><td><em>n</em>b</td><td>Move backward <em>n</em> pages.</td></tr><tr><td>/<em>word</em></td><td>Search forward for <em>word</em>.</td></tr><tr><td>?<em>word</em></td><td>Search backward for <em>word</em>.</td></tr><tr><td>v</td><td>Start the <strong>vi</strong> editor at this point.</td></tr><tr><td>[CTRL-L]</td><td>Redisplay current page.</td></tr><tr><td>h</td><td>Help.</td></tr><tr><td>:n</td><td>Go to next file on command line.</td></tr><tr><td>:p</td><td>Go back to previous file on command line.</td></tr><tr><td>q</td><td>Quit <strong>more</strong> (before end of file).</td></tr></tbody></table></li><li><p>pg</p><p>有的unix系统版本没有more命令，而是提供类似功能的pg。pg可以让你移动到指定的行。pg命令在新显示文件内容时，在最后一行显示一个<code>:</code>提示符，按下回车浏览下一页，按下<code>q</code>键会退出pg，按下<code>h</code>会列出pg命令的列表。</p><h5 id=保护和共享文件>保护和共享文件</h5></li></ul><p>在Unix下共享文件和目录很容易，如何精准控制访问权限很重要。</p><ul><li><p><strong>目录的访问权限</strong></p><p>目录的访问权限将影响到其下面的文件和子目录，获得了目录访问权限后，读取和修改目录下文件的内容是由文件的权限决定的。</p></li><li><p><strong>Unix权限的简单理解</strong></p><ul><li><p>rwx 分别代表read、write 、execute</p></li><li><p>三位分别代user、group、others</p></li><li><p>rwx三种权限的权重数值:r-4，w-2,x-1</p><ul><li><p>rwx：4+2+1=7</p></li><li><p>rw: 4+2=6</p></li><li><p>rx: 4+1=5</p></li></ul></li><li><p>常见的几个权限数值</p><p>755：rwxr-x-r-x (文件的owner拥有rwx三种权限，所以数值为7；group和others 只有rx权限，没有w权限，所以数值为5，表示方法为r-x)</p></li><li><p><code>chmod</code> 语法</p><ul><li>chmod abc dirname-filename 这里的abc三位分别代user、group、others。</li><li>u-g-o三位的表示方法为rwx-rwx-rwx,中间的短横线只是在这里方便显示，在真实的unix系统中使用<code>ls -al</code>显示，一般为<code>drwxr-xr-x</code>,或者<code>-rwxr-xr-x</code></li><li><code>chmod 777 dir-name</code> 、<code>chmod 755 dir-name</code>等类似的写法。</li></ul></li></ul></li><li><p><strong>工作目录权限设置方案</strong></p><ul><li><p>为了防止自己无意中删除目录下的文件和子目录，把工作目录权限设置为555：<code>chmod 555 your-work-directory/</code>；为了防止自己无意中删除目录下的文件和子目录，同时拒绝其他人的访问，把工作目录的权限设置为500：<code>chmod 500 your-work-directory</code>。</p></li><li><p>为了自己可以在工作目录做任何操作，同时拒绝其他用户访问，把工作目录权限设置为700：<code>chmod 700 you-work-directory/</code></p></li><li><p>为了让自己可以在工作目录做任何操作，让其他用户可以看到该工作目录下文件和子目录，把工作目录权限设置为755：<code>chmod 755 you-work-directory/</code>。如果想让其他用户可以编辑工作目录下的文件的话，需要单独把某个文件的写权限分配其他用户，比如<code>chmod go+w file-name</code>。也就是说目录和文件的权限是单独设置共同起效的。</p></li><li><p>为了让同组用户可以完全操作该目录下的文件和子目录，同时让其他用户访问该目录下的文件和子目录，把工作目录权限设置为775：<code>chmod 755 you-work-directory</code>。如果其他用户要编辑其下面的文件，需要单独设置文件的写权限。<code>chmod o+w dir-name/file-name.txt</code></p></li><li><p>给Unix系统上的所有用户分配所有权限，设置工作目录权限为777：<code>chmod 777 work-directory-name/</code></p><blockquote><p>注意：上面几个<code>chmod</code>命令设置目录权限时，在目录名称后边跟了一个<code>/</code>，以明确告知shell，这里是操作目录。</p></blockquote><blockquote><p>设置权限时，目录和文件的权限可以单独设置，组合起效。</p></blockquote><blockquote><p>注意：为了访问一个指定的目录，那么从该目录到<code>root</code>之间的所有父目录都需要有execution（x）权限</p></blockquote></li></ul></li><li><p><strong>文件的访问权限</strong></p><p>文件的访问权限决定着可以对文件做哪些操作。文件所在的目录的访问权限控制着文件能否被编辑和删除。</p><ul><li><p>为了让一个私有的文件只能被你自己编辑，其他人不能访问，权限设置为600：<code>chmod 600 filename</code>;为了防止被自己无意中编辑，设置为400：<code>chmod 400 filename</code>。</p></li><li><p>一个文件只能被自己编辑，其他人只能查看，设置文件权限为644：`chmod 644 filename&rsquo;。</p></li><li><p>一个文件只能被自己和用户组的成员编辑，其他用户不能访问，文件权限设置为660：<code>chmod 660 filename</code></p></li><li><p>为了让非用户组组成员只能查看，用户和组成员可以编辑，设置全系为664：<code>chmod 664 filename</code></p></li><li><p>让系统中的任何用户都可以编辑该文件，设置文件权限为666：<code>chmod 666 filename</code></p><blockquote><p>上面涉及到文件编辑的权限，用的最多的权限是6(rw)或者4(r)</p></blockquote><blockquote><p>如果是可执行文件，这要涉及到x权限。</p></blockquote></li></ul></li><li><p><strong>Linux的<code>chattr</code></strong></p></li></ul><p>​ 多数Linux系统提供了chattr命令，在设置文件和目录权限上有更多的选择。比如，chattr可以设置文件为append-only，只能追加不能被覆盖；可以被压缩用来节省磁盘空间；设置为immutable，根本不能被修改等等多种选择，具体细节可以查看在线文档。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># I get the message &#34;chmod: Not owner.&#34;</span>
</span></span><span class=line><span class=cl>Only the owner of a file or directory can <span class=nb>set</span> its permissions. 
</span></span><span class=line><span class=cl>Use ls -l to find the owner.
</span></span></code></pre></div><h5 id=unix中的电子邮件>Unix中的电子邮件</h5><p>你可以在Unix中撰写信息，通过邮件的形式发送给指定用户。Unix中有很多邮件程序，一些Unix系统有古老而简单的的mail邮件程序。大多数Unix系统有Berkely的<code>Mail</code>(大写M)、mailx、mail邮件程序，还有一个受人欢迎的以菜单驱动且简单易学的邮件程序pine。所有这些邮件程序的基本原理都是相同的。</p><p>以Berkely的mail邮件程序为例。在邮件接受者登录系统并浏览邮件之前，你发送的邮件信息保存在/usr/mail目录下的文件中。发送邮件的语法如下：</p><blockquote><p>mail address1 address2 &mldr;</p></blockquote><blockquote><p>最常见的地址语法格式为：username@hostname，为了保存邮件的副本，可以把自己的地址也添加在邮件地址列表中。</p></blockquote><blockquote><p>在输入完成邮件信息内容后，在单独一行输入一次<code>ctrl+d</code>，完成邮件编辑发送，退回到shell prompt。</p></blockquote><blockquote><p>If you change your mind before you type [CTRL-D] you can</p><p>cancel a message (while you are still entering text) by entering <strong>~q</strong> (a tilde character, then the letter</p><p>&ldquo;q&rdquo;) at the start of a line. The cancelled message is placed in a file called <em>dead.letter</em> in your home</p><p>directory. To see other commands you can use while sending mail, enter <strong>~?</strong> (tilde question mark)</p><p>at the start of a line of your message, then press [RETURN]. To redisplay your message after</p><p>using <strong>~?</strong>, enter <strong>~p</strong> at the start of a line.</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>#邮件撰写及发送的例子
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>% mail alicia@moxco.chi.il.us
</span></span><span class=line><span class=cl>Subject: My trip to Chicago is on!
</span></span><span class=line><span class=cl>Alicia, I will be able to attend your meeting.
</span></span><span class=line><span class=cl>Please send me the agenda. Thanks.
</span></span><span class=line><span class=cl>^D
</span></span><span class=line><span class=cl>%
</span></span></code></pre></div><ul><li><p>读取邮件</p><p>在shell 提示符下输入mail，进入mail程序</p></li></ul><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>% mail
</span></span><span class=line><span class=cl>Mail version SMI 4.0 Wed Oct 23 10:38:28 PDT 1991  Type ? for help.
</span></span><span class=line><span class=cl>&#34;/usr/spool/mail/alicia&#34;: 2 messages 1 new
</span></span><span class=line><span class=cl>&gt;U  1 bigboss         Sat May 22 06:56  19/529  In your spare time
</span></span><span class=line><span class=cl>N  2 jpeek@jpeek.com Tue Nov  4 14:25  14/362  My trip to Chicago
</span></span><span class=line><span class=cl># 注释：&amp; 是mail程序的命令提示符
</span></span><span class=line><span class=cl>&amp; 2
</span></span><span class=line><span class=cl>Message 2:
</span></span><span class=line><span class=cl>Date: Tue, 4 Nov 1997 14:25:43 EST
</span></span><span class=line><span class=cl>From: jpeek@jpeek.com (Jerry Peek)
</span></span><span class=line><span class=cl>To: alicia@moxco.chi.il.us
</span></span><span class=line><span class=cl>Subject: My trip to Chicago is on!
</span></span><span class=line><span class=cl>Alicia, I will be able to attend your meeting.
</span></span><span class=line><span class=cl>Please send me the agenda.  Thanks.
</span></span><span class=line><span class=cl># 注释：d删除当前右键
</span></span><span class=line><span class=cl>&amp; d
</span></span><span class=line><span class=cl># 注释：退出mail回到Unix shell prompte
</span></span><span class=line><span class=cl>&amp; q
</span></span><span class=line><span class=cl>Held 1 message in /usr/spool/mail/alicia
</span></span><span class=line><span class=cl>%
</span></span></code></pre></div></blockquote><p>When you start <strong>mail</strong>, it prints a &ldquo;message header&rdquo; that shows whether each message is &ldquo;new&rdquo; (N) or &ldquo;unread&rdquo; (U), a message number, the sender, and when the message was sent. A &ldquo;>&rdquo; marks the current message. You can read any message by entering its number; if you use a command without a number, the command acts on the current message. If you read a message and don&rsquo;t delete it, the message is automatically moved to a file called <em>mbox</em> in your home directory.</p><p>The output of <strong>mail</strong> says that the message was sent by Jerry on Tuesday, November 4, at 2:25 p.m. The ampersand (&) on the last line is the <strong>mail</strong> program prompt. Just as the UNIX shell prompt is a sign that the shell is waiting for you to enter a command, the mail prompt is a sign that the <strong>mail</strong> program is waiting for you to enter a mail command. Your mail prompt may consist of a single character. Learn the mail prompt on your system and enter one of the commands in <a href=ch03_04.htm#LUX-CH-3-TAB-1>Table 3.2</a>. For instance, Alicia might have chosen to enter <strong>r</strong> to reply to Jerry before using <strong>d</strong> to delete his message.</p><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td>?</td><td>Display menu of mail commands.</td></tr><tr><td>#</td><td>Show message number #.</td></tr><tr><td>n</td><td>Display the next message.</td></tr><tr><td>p</td><td>Display current message.</td></tr><tr><td>d</td><td>Delete the message. Messages you read and don&rsquo;t delete are saved in <em>mbox</em>.</td></tr><tr><td>m <em>addrs</em></td><td>Mail a message to the addresses <em>addrs</em>.</td></tr><tr><td>r</td><td>Reply to sender of current message.</td></tr><tr><td>R</td><td>Reply to sender and other recipients of current message.</td></tr><tr><td>s <em>file</em></td><td>Save a message in the named <em>file</em>.</td></tr><tr><td>file <em>file</em></td><td>Handle the messages in the named <em>file</em>.</td></tr><tr><td>file %</td><td>Handle the messages in your system mailbox.</td></tr><tr><td>h</td><td>Display summary of messages.</td></tr><tr><td>q</td><td>Quit the <strong>mail</strong> program.</td></tr><tr><td>x</td><td>Exit the <strong>mail</strong> program, ignoring any changes you made during this session.</td></tr></tbody></table><h5 id=自定义你的账户>自定义你的账户</h5><p>在你的Unix主目录下，可能会有一个隐藏的名称为.profile的文件，如果不是这个文件，那可能会有其他一个或者多个隐藏的文件，比如：<code> .login, .cshrc, .tshrc, .bashrc, .bash_profile, or .bash_login</code>。这些文件是设置自定义shell的关键所在。当你login时或者开启新的shell时，设置文件中的命令会自动运行，任何可以在shell prompt下运行的命令都可以放在设置文件中，当登录shell时就会自动运行。</p><p>使用cat命令分别查看.profile和.login文件的内容如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>PATH</span><span class=o>=/</span><span class=n>bin</span><span class=p>:</span><span class=o>/</span><span class=n>usr</span><span class=o>/</span><span class=n>bin</span><span class=p>:</span><span class=o>/</span><span class=n>usr</span><span class=o>/</span><span class=n>local</span><span class=o>/</span><span class=n>bin</span><span class=p>:</span>
</span></span><span class=line><span class=cl><span class=k>export</span> <span class=n>PATH</span>
</span></span><span class=line><span class=cl><span class=o>/</span><span class=n>usr</span><span class=o>/</span><span class=n>games</span><span class=o>/</span><span class=n>fortune</span>
</span></span><span class=line><span class=cl><span class=n>date</span>
</span></span><span class=line><span class=cl><span class=n>umask</span> <span class=mi>002</span>
</span></span><span class=line><span class=cl><span class=n>stty</span> <span class=n>erase</span> <span class=o>^</span><span class=n>H</span> <span class=n>intr</span> <span class=o>^</span><span class=n>C</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>set path = (/bin /usr/bin /usr/local/bin .)
</span></span><span class=line><span class=cl>/usr/games
</span></span><span class=line><span class=cl>date
</span></span><span class=line><span class=cl>umask 002
</span></span><span class=line><span class=cl>stty erase ^H intr ^C
</span></span></code></pre></div><p>文件中的<code>PATH=</code>or <code>set path = </code>用来告诉 shell搜索路径，在运行命令时不必输入绝对路径。 第一种方法用<code>:</code>分隔多个目录，第二种方法用空格分隔多个目录。</p><blockquote><p>The <strong>umask</strong> command sets the default file permissions assigned to all files you create.</p><p>Briefly, a value of 022 sets the permissions rw-r&ndash;r&ndash; (read-write by owner, but read-only by</p><p>everyone else), and 002 will produce rw-rw-r&ndash; (read-write by owner and group, but read</p><p>only by everyone else). If this file is a program or a directory, both <strong>umasks</strong> will also give</p><p>execute ( x ) permission to all users.</p></blockquote><p><code>stty erase ^H intr ^C</code>用来设置终端的控制字符，删除使用<code>ctrl+h</code>键，中断使用<code>ctrl+c</code>键。控制字符也可以在shell prompt下使用命令来设置，比如：</p><blockquote><p>% stty erase ^? 这里删除控制字符就设置为<code>ctrl+?</code>键。</p></blockquote><h5 id=unix文件管理>Unix文件管理</h5><ul><li><p>建立文件的几种方法</p><ul><li>使用vi、emacs、pico等编辑器来新建文件</li><li>使用unix的重定向(<code>></code>、<code>>></code>)功能把命令行输出保存到文件</li></ul></li><li><p>文件和目录名称</p><p>目录实际上一种特殊的文件，因此目录的名称和文件的名称遵循一个标准。除了<code>/</code>这个字符外（作为文件路径中的分隔符），其他字符都可以应用到文件名称。文件名称一般由大小写字母、数字、<code>.</code>、下划线<code>_</code>和其他字符组成，甚至空格也可以出现在文件名称中，建议使用字母、数字、<code>.</code>、<code>_</code>四类字符作为文件名称。一些Unix系统限制文件名称不超过14个字符，多数新系统支持更长的文件名长度。</p></li><li><p>文件和目录名称的通配符</p><p>常用的通配符有<code>*</code>，<code>?</code>，<code>[]</code>，这些用在文件名中的通配符作为参数传递给使用的命令</p><ul><li><p><code>*</code>表示0个、1个或者任意多个字符。比如<code>*al* for alphabet.txt</code>，第一个<code>*</code>表示0个字符，也就是字母<code>a</code>前边可以没有字符。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>% ls  *a*a*  
</span></span><span class=line><span class=cl>可以匹配到
</span></span><span class=line><span class=cl>aha   首尾的*匹配0个任意字符，也就是说没有任何字符，中间的*匹配了一个h,最后匹配为aha
</span></span><span class=line><span class=cl>aa    a*a中间的*匹配0个字符，也就是没有字符，最后匹配成了aa
</span></span><span class=line><span class=cl>xaaax  收尾的*号匹配了两个x,中间的*匹配了一个字母a,最后匹配成了xaaax
</span></span></code></pre></div></li><li><p><code>?</code>表示单个任意字符</p></li><li><p><code>[]</code>在方括号中间的多个不同字符，匹配单个字符。也可以使用连字符<code>-</code>来分隔一个范围的连续字符，比如 <em>chap</em>[1-3] 将匹配 chap1,chap2, or chap3。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>% ls  [CcHh]apt
</span></span><span class=line><span class=cl>最终匹配为capt、hapt
</span></span></code></pre></div><p>通配符不仅仅应用在文件列表方面。很多Unix命令接受多个文件名参数，这样就可以使用通配符放在命令行。比如 :</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>% more *.old
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>This is equivalent to &#34;**more chap1a.old chap3.old**&#34;.
</span></span></code></pre></div></li></ul></li><li><p>管理文件</p><ul><li>建立目录（根据文件功能分类建立不同的目录）</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=o>%</span> <span class=n>mkdir</span>  <span class=n>tools</span>  <span class=n>app</span>
</span></span></code></pre></div><ul><li><p>复制文件</p><blockquote><p>cp oldname newname</p><p>cp /etc/passwd password</p><p>&ndash;这条命令是换名复制,把/etc/passwd文件复制到工作目录下的password</p></blockquote><blockquote><p>cp old dir</p><p>&ndash;这条命令是同名复制到其他目录</p></blockquote><blockquote><p>% cp ../john/ch1 ../john/ch2 ../john/ch3 work</p><p>&ndash;将多个文件复制到work目录下</p></blockquote><blockquote><p>% cp -i ../john/ch[1-3] work</p><p>cp: overwrite work/ch2? n</p><p>这条命令添加-i参数，在有覆盖文件时提示是否覆盖，并在命令中使用文件名称通配符匹配</p></blockquote><blockquote><p>% cp ../john/ch[1-3] .</p><p>这条命令复制文件到当前的工作目录下，用<code>.</code>表示当前目录，也就是工作目录</p></blockquote><p>在复制文件时常见的几种错误：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-zed data-lang=zed><span class=line><span class=cl><span class=err>#</span><span class=w>  </span><span class=err>&#34;</span><span class=n>cp</span><span class=o>:</span><span class=w> </span><span class=n>cannot</span><span class=w> </span><span class=n>copy</span><span class=w> </span><span class=n>file</span><span class=w> </span><span class=n>to</span><span class=w> </span><span class=n>itself</span><span class=err>&#34;</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>在同一个目录下复制文件时，两个文件名称要不同</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>#</span><span class=w>  </span><span class=err>&#34;</span><span class=n>cp</span><span class=o>:</span><span class=w> </span><span class=n>filename</span><span class=o>:</span><span class=w> </span><span class=n>no</span><span class=w> </span><span class=n>such</span><span class=w> </span><span class=n>file</span><span class=w> </span><span class=n>or</span><span class=w> </span><span class=n>directory</span><span class=err>&#34;</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>检查文件和目录名称是否拼写正确，如果要复制的文件不在工作目录，要使用正确的路径</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>#</span><span class=w> </span><span class=n>cp</span><span class=o>:</span><span class=w> </span><span class=kd>permission</span><span class=w> </span><span class=n>denied</span><span class=err>&#34;</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>你可能没有复制其他用户创建的文件的权限；或者对的目标目录没有权限。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>可以使用</span><span class=w> </span><span class=n>ls</span><span class=w> </span><span class=o>-</span><span class=n>l</span><span class=w> </span><span class=err>查看文件的</span><span class=n>ower和权限</span><span class=err>，或者使用</span><span class=n>ls</span><span class=w> </span><span class=o>-</span><span class=n>ld</span><span class=w> </span><span class=err>查看一下目录的权限</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>申请管理员更改文件和目录的访问权限</span><span class=w>
</span></span></span></code></pre></div></li><li><p>远程复制rcp</p><p>可以使用rcp在本地计算机和远程计算机之间，或者在远程计算机之间复制文件</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>% rcp giraffe:report.may giraffe:report.june .
</span></span><span class=line><span class=cl>这条命令把主机名称为giraffe的两个文件：report.may和report.june复制到工作目录下
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>% rcp &#34;giraffe:food/lunch/*&#34; .
</span></span><span class=line><span class=cl>这条命令把主机名称为giraffe上的food/lunch/目录下的所有文件复制到当前的工作目录`.`
</span></span><span class=line><span class=cl>rcp中使用通配符时，要使用&#34;&#34;把主机名称和文件名包括进来。
</span></span></code></pre></div><p>rcp命令并没有交互式的参数<code>i</code>，因为安全的原因，管理员并不倾向于让用户使用rcp来复制文件，而是推荐使用ftp。</p></li><li><p>ftp</p><p>使用ftp在两台计算机之间通过网络传输文件，两台计算机不必都运行Unix系统。</p><p>运行ftp后，ftp会提示你输入远程计算机的用户名和密码，有点类似远程登录的样子。ftp会显示自己的命令提示符，输入相关的命令来完成文件的传输。下面显示ftp的command。</p></li></ul></li></ul><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><strong>put</strong> <em>filename</em></td><td>Copies the file <em>filename</em> from your local computer to the remote computer. If you give a second argument, the remote copy will have that name.</td></tr><tr><td><strong>mput</strong> <em>filenames</em></td><td>Copies the named files (you can use wildcards) from local to remote.</td></tr><tr><td><strong>get</strong> <em>filename</em></td><td>Copies the file <em>filename</em> from the remote computer to your local computer. If you give a second argument, the local copy will have that name.</td></tr><tr><td><strong>mget</strong> <em>filenames</em></td><td>Copies the named files (you can use wildcards) from remote to local.</td></tr><tr><td><strong>cd</strong> <em>pathname</em></td><td>Changes the working directory on the remote machine to <em>pathname</em> (<strong>ftp</strong> usually starts at your home directory on the remote machine).</td></tr><tr><td><strong>lcd</strong> <em>pathname</em></td><td>Changes <strong>ftp</strong>&rsquo;s working directory on the local machine to <em>pathname</em> (<strong>ftp</strong> starts at your working directory on the local computer). Note that the <strong>ftp lcd</strong> command changes only <strong>ftp</strong>&rsquo;s working directory. After you quit <strong>ftp</strong>, your shell&rsquo;s working directory will not have changed.</td></tr><tr><td><strong>dir</strong></td><td>Lists the remote directory (like <strong>ls -l</strong>).</td></tr><tr><td><strong>binary</strong></td><td>Tells <strong>ftp</strong> to copy the following file(s) without translation. This preserves pictures, sound, or other data.</td></tr><tr><td><strong>ascii</strong></td><td>Transfers plain text files, translating data if needed.</td></tr><tr><td><strong>quit</strong></td><td>Ends the <strong>ftp</strong> session and takes you back to a shell prompt.</td></tr></tbody></table><p>Entering <strong>help</strong> at an <code>ftp></code> prompt gives a list of all commands; entering <strong>help</strong> followed by an <strong>ftp</strong> command name gives a one-line summary of that command.</p><p>下面的例子是登录ftp,把远程主机rhino上work目录下的todo文件复制到本地机器的工作目录。</p><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>% ls
</span></span><span class=line><span class=cl>afile   ch2    somefile
</span></span><span class=line><span class=cl>% ftp rhino
</span></span><span class=line><span class=cl>Connected to rhino.zoo.com.
</span></span><span class=line><span class=cl>Name (rhino:carol): csmith
</span></span><span class=line><span class=cl>Password:
</span></span><span class=line><span class=cl>ftp&gt; cd work
</span></span><span class=line><span class=cl>ftp&gt; dir
</span></span><span class=line><span class=cl>total 3
</span></span><span class=line><span class=cl>-rw-r--r--  1 csmith   mgmt    47 Feb  5  1997 for.ed
</span></span><span class=line><span class=cl>-rw-r--r--  1 csmith   mgmt   264 Oct 11 12:18 message
</span></span><span class=line><span class=cl>-rw-r--r--  1 csmith   mgmt   724 Nov 20 14:53 todo
</span></span><span class=line><span class=cl>ftp&gt; get todo
</span></span><span class=line><span class=cl>ftp&gt; quit
</span></span><span class=line><span class=cl>% ls
</span></span><span class=line><span class=cl>afile   ch2    somefile    todo
</span></span></code></pre></div></blockquote><ul><li><p>重命名和移动文件</p><p>使用<code>mv</code>命令可以重命名文件名称，也可以把文件移动到其他目录(正如mv命令的名字所示：move)。</p><blockquote><p>mv oldname newname</p><p>mv命令可以覆盖存在的同名文件，可以实现文件版本的更新。如果不想覆盖存在的文件，要确认文件名称，也可以带上交互式的<code>i</code>参数，在覆盖式给出提示信息。</p><p>mv 完成名称变更后，使用<code>ls</code> 命令查询会发现oldname就不见了。</p></blockquote><blockquote><p>mv filename /users/work1/</p><p>把文件移动到指定目录</p></blockquote></li><li><p>搜索文件（find）</p><p>先把目录切换到自己的主目录，让<code>find</code>命令从这里开始搜索。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># 不带任何参数的cd命令切换工作目录到用户主目录
</span></span><span class=line><span class=cl>% cd
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 在.代表的当前目录下查找type为file ,名称为chap*的文件，并打印出来
</span></span><span class=line><span class=cl>% find . -type f -name &#39;chap*&#39; -print
</span></span><span class=line><span class=cl>./chap2
</span></span><span class=line><span class=cl>./old/chap10b
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 在.代表的当前目录下查找type为file,-mtime 修改时间为2天的文件
</span></span><span class=line><span class=cl>% find . -type f -mtime -2 -print
</span></span><span class=line><span class=cl>./work/to_do
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>&gt;The first command looked in your working (home) directory and all its subdirectories for files
</span></span><span class=line><span class=cl>&gt;(type f) whose names start with chap. (find understands wildcards in filenames.) The second
</span></span><span class=line><span class=cl>&gt;command looked for all files that have been created or modified in the last two days (-mtime -2).
</span></span><span class=line><span class=cl>&gt;The relative pathnames that find finds start with a dot (./), the name of the working directory,
</span></span><span class=line><span class=cl>&gt;which you can ignore.
</span></span></code></pre></div><p>在Linux系统中，可以使用locate来查找文件，详细文档可以查询Linux文档</p><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>% locate alpha
</span></span><span class=line><span class=cl>/users/alan/alpha3
</span></span><span class=line><span class=cl>/usr/local/projects/mega/alphatest
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>这条命令查找包含alpha的所有文件，是通过绝对路径显示的
</span></span></code></pre></div></blockquote></li><li><p>删除文件和目录</p><ul><li><p>rm filename</p><p>使用rm删除文件时，可以在文件名中使用通配符，但是一定要养成好习惯，在删除之前使用<code>ls </code>附带这些要删除的、使用通配符表示的文件列表，确认一下是否是自己要删除的文件列表。比如:</p><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>% ls c*
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>% rm c*
</span></span><span class=line><span class=cl>注意这个c*的写法，字符c和*号之间一定不能有空格，c*和c *是完全不一样的表达，前者是删除字母c开头的所有文件，后者是删除名称为c的文件和所有文件。
</span></span></code></pre></div></blockquote></li><li><p>rmdir dirname</p><p>使用rmdir可以删除一个目录，但是目录下面有文件和子目录时，无法删除该目录。因此，要删除一个目录，首先要切换到该目录下，删除下面的所有文件，然后再切换回来，使用<code>rmdir dirname</code>来删除目录。</p><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>To delete a directory that contains some files:
</span></span><span class=line><span class=cl>1. Enter cd dirname to get into the directory you want to delete.
</span></span><span class=line><span class=cl>2. Enter rm * to remove all files in that directory.
</span></span><span class=line><span class=cl>3. Enter cd .. to go to the parent directory.
</span></span><span class=line><span class=cl>4. Enter rmdir dirname to remove the unwanted directory
</span></span></code></pre></div></blockquote></li></ul></li></ul><p>​ 当然，对unix的目录和文件操作熟悉了以后，可以使用<code>rm -r dirname</code>来彻底删除一个目录拥有的所有内容。这里的<code>r</code>代表recursive。</p><ul><li><p>打印文件</p><p>在Unix中打印文件之前，可以使用文本格式化工具把文件重新排版一下，打印出来更美观。大多数Unix自带两个强大而复杂的工具：nroff 、troff，当然，还有一个相对简单的pr。</p><ul><li>pr <em>option(s) filename(s)</em></li></ul><p>pr只是把格式化的内容显示在屏幕或者打印机，并不是修改源文件。下表显示了部分pr命令的选项</p><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td>-<em>k</em></td><td>Produces <em>k</em> columns of output.</td></tr><tr><td>-d</td><td>Double-spaces the output (not on all <strong>pr</strong> versions).</td></tr><tr><td>-h &ldquo;<em>header</em>&rdquo;</td><td>Takes the next item as a report <em>header</em>.</td></tr><tr><td>-t</td><td>Eliminates printing of header and top/bottom margins.</td></tr></tbody></table><p>还有一下其他选项用来指定列宽，设置页面长度等等。</p><p>下面是一个带有Header的两列的报告</p><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=o>%</span> <span class=n>pr</span> <span class=o>-</span><span class=mi>2</span> <span class=o>-</span><span class=n>h</span> <span class=s2>&#34;developtment tools&#34;</span> <span class=n>food</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Nov</span>  <span class=mi>7</span>  <span class=mi>9</span><span class=p>:</span><span class=mi>58</span> <span class=mi>1997</span>  <span class=n>developtment</span> <span class=n>tools</span>   <span class=n>Page</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>perl</span>                  <span class=n>c</span>
</span></span><span class=line><span class=cl><span class=n>php</span>                   <span class=n>c</span><span class=o>++</span>
</span></span><span class=line><span class=cl><span class=n>python</span>               <span class=n>java</span>
</span></span><span class=line><span class=cl><span class=n>javascript</span>             <span class=n>go</span> 
</span></span><span class=line><span class=cl>	<span class=o>.</span>
</span></span><span class=line><span class=cl>	<span class=o>.</span>
</span></span><span class=line><span class=cl><span class=o>%</span>
</span></span></code></pre></div></blockquote><p>可以在pr后边使用一个<code>pipe</code> ,把内容给输出到打印机（ <strong>lp</strong> or <strong>lpr</strong>）</p><ul><li><p><strong>lp</strong> or <strong>lpr</strong></p><p>你的Unix系统会包含两者中的其中之一。可以把文件打印到默认的组内成员共享的打印机上。</p><blockquote><p>lp docname</p></blockquote></li><li><p>查看打印队列</p><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>If you want to find out how many files or &#34;requests&#34; for output are ahead of yours in the printer 
</span></span><span class=line><span class=cl>queue, use the command lpstat (for lp) or lpq (for lpr). The cancel command lets you terminate
</span></span><span class=line><span class=cl>a printing request made by lp; lprm cancels jobs from lpr.
</span></span></code></pre></div></blockquote><blockquote><p>&ndash; 注释：下面的命令显示有所的打印任务</p><p>% lpstat -o
laserp-573 john 128865 Nov 7 11:27 on laserp
laserp-574 grace 82744 Nov 7 11:28
laserp-575 john 23347 Nov 7 11:35
%</p></blockquote></li><li><p>取消打印(cancel and lprm)</p><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>cancel terminates a printing request from the lp command. lprm terminates lpr requests. You
</span></span><span class=line><span class=cl>can specify either the ID of the request (displayed by lp or lpq) or the name of the printer.
</span></span><span class=line><span class=cl>If you don&#39;t have the request ID, get it from lpstat or lpq. Then use cancel or lprm. Specifying 
</span></span><span class=line><span class=cl>the request ID cancels the request, even if it is currently printing
</span></span></code></pre></div></blockquote></li></ul></li></ul><h5 id=输入输出的重定向>输入输出的重定向</h5><p>通常情况下，Unix命令从键盘获得输入数据，把运行结果显示在屏幕上，这是标准的输入和输出。很多Unix命令都会带一个文件名作为参数输入，如果不带文件参数，那么这个命令就会从键盘获得输入，这就是标准输入。</p><blockquote><p>cat filenmae</p><p>这种形式属于正常的参数传递机制，不属于输入重定向的范畴</p></blockquote><blockquote><p>cat</p><p>不带参数的形式，就会进入标准输入模式</p></blockquote><p>这里主要说明标准的输入输出和输入输出的重定向，而正常的带参数命令调用不在这个范围。但是如果命令调用时不指定参数，接受输入的命令就会进入到标准输入模式，接受用户从键盘输入数据。</p><ul><li><p>输入的重定向</p><p>把一个文件名以非参数传递的形式传递给Unix命令，这样的形式就是输入重定向。比如：</p><blockquote><p>% mail bigboss@corp &lt; to_do</p><p>输入重定向的操作符为"&lt;"</p></blockquote></li><li><p>输出重定向</p><p>可以把命令行的结果输出重定向到一个新的文件中，或者其他设备，而不是标准输出在屏幕上。输出重定向操作符为<code>></code>和<code>>></code>。当然管道操作符<code>|</code>也属于输出重定向范畴，把一个命令的输出通过<code>|</code>变成另外一个命令的输入（或者说|左边的命令行输出作为|右边命令的输入），还可以在一个命令行中使用多个管道操作符。</p><ul><li><p><code>></code>操作符</p><p>可以使用<code>cat > filename</code>来新建一个文件。正常情况下，<code>cat filename</code>会在屏幕上显示文件的内容，但是cat命令后边不带文件作为参数的话，就会转换为从标准输入中获得数据，然后再配合<code>></code>的使用，就可以把输入的内容保存在一个文件中。示例如下：</p><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>% cat &gt; to_do
</span></span><span class=line><span class=cl>learn  the unix  operating system
</span></span><span class=line><span class=cl>build  note for  my learn of the  unix  operating system
</span></span><span class=line><span class=cl>learn  linux bible
</span></span><span class=line><span class=cl>^D
</span></span><span class=line><span class=cl>%
</span></span></code></pre></div><p>Type [CTRL-D] on a new line by itself to signal the end of the text. You should get a shell prompt.</p></blockquote><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>cat file1 file2 &gt; newfile
</span></span></code></pre></div><p>使用这种方式可以把两个小文件合并为一个文件</p></blockquote><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>使用`&gt;`实现重定向功能，可能会覆盖现存文件。很多shell能够保护现存文件不被重定向覆盖。在C shell中，使用`set noclobber`，在Korn shell和bash中，使用`set -o noclobber`。可以把这些命令写在shell的启动文件中，shell就不允许重定向到一个现存文件中而导致文件内容丢失
</span></span></code></pre></div></blockquote></li><li><p><code>>></code>操作符</p><p>都是重定向输出操作符，和<code>></code>操作符不同，该操作符是在文件尾部追加的形式添加内容。</p></li></ul></li><li><p>管道和过滤器</p><p>除了重定向输入输出到一个文件之外，你可以把两个命令连接起来，一个程序的输出变成另外一个程序的输入。把两个或者更多的命令连接起来形成一个管道（pipe）。在Unix中使用<code>|</code>操作符来构建一个管道，<code>|</code>左侧的命令行的标准输出变成<code>|</code>右侧命令的标准输入。在Unix中，只要一个程序能够把数据写入到标出输出，而另外一个程序可以从标准输入中读取数据，任何这样的两个程序都可以组成一个管道。</p><p>一个程序读取另外一个程序的输出数据，然后对这个读取的数据进行加工或者筛选，再次以管道的形式输出给下一个程序，或者最终输出到屏幕，这个过程叫做过滤。Unix的过滤器作用就是挑选数据后再次重构输出。几乎所有的Unix命令都可以用来形成管道。一部分程序除了自身的强大功能之外，常被用来作为过滤器使用，比如<code>grep</code>、<code>sort</code>、<code>pg</code>、<code>more</code>。</p><ul><li><p><code>grep</code></p><p><code>grep</code>的名字来源于行编辑器<code>ed</code>的<code>g/re/p</code>命令，意思是全局搜索正则表达式并打印包含它的所有行。</p><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>% ls -l | grep &#34;Aug&#34;
</span></span><span class=line><span class=cl>-rw-rw-rw- 1 john doc 11008 Aug 6 14:10 ch02
</span></span><span class=line><span class=cl>-rw-rw-rw- 1 john doc 8515 Aug 6 15:30 ch07
</span></span><span class=line><span class=cl>-rw-rw-r-- 1 john doc 2488 Aug 15 10:51 intro
</span></span><span class=line><span class=cl>-rw-rw-r-- 1 carol doc 1605 Aug 23 07:35 macros
</span></span><span class=line><span class=cl>%
</span></span></code></pre></div><p>把 <code>ls -l</code> 的输出通过管道输入给grep，grep搜索包含"Aug"的行，输出到屏幕</p></blockquote><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>% ls -l | grep &#34;carol.*Aug&#34;
</span></span><span class=line><span class=cl>-rw-rw-r-- 1 carol doc 1605 Aug 23 07:35 macros
</span></span><span class=line><span class=cl>%
</span></span></code></pre></div><p>在grep后面的正则表达式中，<code>carol</code>和后边的<code>.*Aug</code>之间是有空格的，是两个分开的模式。其中<code>.*</code>组合在一起表示任意数量的单个字符，<code>.</code>表示任意单个字符，而<code>*</code>是个量词，用来说明前边的<code>.</code>重复次数。正则表达式里单独的<code>*</code>号没有意义，和文件通配符中的<code>*</code>不同。正则表达式很复杂，这里先了解一点，以后再慢慢学习。</p></blockquote></li><li><p>sort</p><p>sort根据指定的参数按照字母和数字进行排序，但是并不会修改源文件，只是把排序的结果输出到屏幕。sort默认是按照字母顺序排序的，有选项来设置排序规则</p><table><thead><tr><th><strong>Option</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>-n</td><td>Sort numerically (example: 10 will sort after 2), ignore blanks and tabs.</td></tr><tr><td>-r</td><td>Reverse the order of sort.</td></tr><tr><td>-f</td><td>Sort upper- and lowercase together.</td></tr><tr><td>+<em>x</em></td><td>Ignore first <em>x</em> fields when sorting</td></tr></tbody></table><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>% ls -l | grep &#34;Aug&#34; | sort +4n
</span></span><span class=line><span class=cl>-rw-rw-r-- 1 carol doc 1605 Aug 23 07:35 macros
</span></span><span class=line><span class=cl>-rw-rw-r-- 1 john doc 2488 Aug 15 10:51 intro
</span></span><span class=line><span class=cl>-rw-rw-rw- 1 john doc 8515 Aug 6 15:30 ch07
</span></span><span class=line><span class=cl>-rw-rw-rw- 1 john doc 11008 Aug 6 14:10 ch02
</span></span><span class=line><span class=cl>%
</span></span></code></pre></div><p>这个管道把<code>ls -l</code>的显示结果通过‘’Aug“进行搜索，只显示目录下8月份修改的文件，然后使用<code>+4n</code>作为排序参数，意思是跳过前四个字段，使用第五个字段（文件大小）尽心排序，最终显示在屏幕上。</p></blockquote></li><li><p>more、pg</p><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>% ls -l | grep &#34;Aug&#34; | sort +4n | more
</span></span><span class=line><span class=cl>-rw-rw-r-- 1 carol doc 1605 Aug 23 07:35 macros
</span></span><span class=line><span class=cl>-rw-rw-r-- 1 john doc 2488 Aug 15 10:51 intro
</span></span><span class=line><span class=cl>-rw-rw-rw- 1 john doc 8515 Aug 6 15:30 ch07
</span></span><span class=line><span class=cl>-rw-rw-r-- 1 john doc 14827 Aug 9 12:40 ch03
</span></span><span class=line><span class=cl>.
</span></span><span class=line><span class=cl>.
</span></span><span class=line><span class=cl>.
</span></span><span class=line><span class=cl>-rw-rw-rw- 1 john doc 16867 Aug 6 15:56 ch05
</span></span><span class=line><span class=cl>--More--(74%)
</span></span></code></pre></div><p>如果工作目录下的文件很多，一屏显示不下，就可以利用more 或者pg来分屏显示</p></blockquote></li></ul></li></ul><h5 id=unix的多任务>Unix的多任务</h5><ul><li><p>在后台运行命令行</p><p>只需要在命令行的尾部添加一个<code>&</code>就可以让改命令行在后台运行。</p><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>% nroff -ms chap1 &gt; chap1.out &amp;
</span></span><span class=line><span class=cl>[1] 29890
</span></span><span class=line><span class=cl>%
</span></span></code></pre></div><p>nroff是文档格式化程序，一般大一点的文档在格式化时会花点时间，因此更适合在后台运行，而不需要等待。命令行结尾的<code>&</code>前边要有一个空格分开。</p><p>在命令行运行后，显示一个数字，就是PID，有了这PID，可以根据需要进行查询、暂停、终止进程的运行。</p></blockquote><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>在C shell中，可以把多条命令用分号隔开写在一行上，把整个命令行用括号包括，最后在结尾添加`&amp;`。比如：(command1; command2) &amp; 
</span></span></code></pre></div></blockquote><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>在很多Unix系统中，shell有job控制特性，这样你可以使用ctrl+z键来暂停运行在前台的程序，然后会开启一个新的shell，你可以运行各种命令，包括使用bg命令把刚才暂停的程序带入到后台运行，也可以使用fg命令把后台程序转如前台运行。
</span></span></code></pre></div><p>示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>For example, you might start sort running on a big file, and, after a minute, want to send email.
</span></span><span class=line><span class=cl>You stop sort, then put it in the background. The shell prints a message, then another shell
</span></span><span class=line><span class=cl>prompt. You send mail while sort runs
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>% sort hugefile1 hugefile2 &gt; sorted
</span></span><span class=line><span class=cl>...time goes by...
</span></span><span class=line><span class=cl>[CTRL-Z] Stopped
</span></span><span class=line><span class=cl>% bg
</span></span><span class=line><span class=cl>[1] sort hugefile1 hugefile2 &gt; sorted &amp;
</span></span><span class=line><span class=cl>% mail eduardo@nacional.cl
</span></span><span class=line><span class=cl>...
</span></span></code></pre></div><p>在这里先使用ctrl+z暂停程序，然后使用bg把程序带入到后台运行，然后可以做别的任务。</p></blockquote></li><li><p>查看进程</p><ul><li><p>ps （查看进程）</p><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>% ps
</span></span><span class=line><span class=cl>PID TTY TIME COMMAND
</span></span><span class=line><span class=cl>8048 020 0:12 sh
</span></span><span class=line><span class=cl>8699 020 0:02 ps
</span></span><span class=line><span class=cl>%
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>In its basic form, ps lists the following:
</span></span><span class=line><span class=cl>Process ID (PID)
</span></span><span class=line><span class=cl>A unique number assigned by UNIX to the process.
</span></span><span class=line><span class=cl>Terminal line (TTY)
</span></span><span class=line><span class=cl>The terminal number from which the process was started.
</span></span><span class=line><span class=cl>Run time (TIME)
</span></span><span class=line><span class=cl>The amount of computer time (in minutes and seconds) that the process has used.
</span></span><span class=line><span class=cl>Command (COMMAND)
</span></span><span class=line><span class=cl>The name of the process.
</span></span></code></pre></div></blockquote></li><li><p>kill(终止进程）</p></li></ul></li></ul><h5 id=standard-unix-documentation>Standard UNIX Documentation</h5><p>almost all UNIX documentation is derived from a manual originally called the <strong>UNIX Programmer&rsquo;s Manual</strong></p><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>man command
</span></span></code></pre></div></blockquote><h5 id=unix-programming>Unix Programming</h5></div></article></div><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll("pre code").forEach(e=>{hljs.highlightElement(e);const t=document.createElement("button");t.className="copy-code",t.textContent="Copy",t.addEventListener("click",()=>{navigator.clipboard.writeText(e.textContent).then(()=>{t.textContent="Copied!",t.classList.add("copied"),setTimeout(()=>{t.textContent="Copy",t.classList.remove("copied")},2e3)})}),e.parentElement.prepend(t)});const o=document.querySelectorAll(".article-content h2[id], .article-content h3[id]"),i=document.querySelectorAll('.toc a[href^="#"]'),a=document.querySelector(".top-nav").offsetHeight,n=document.querySelector(".toc-container"),e=[];o.forEach(t=>{e.push({id:t.id,top:t.offsetTop-a-20})});function s(){const s=window.scrollY;let t="";for(let n=e.length-1;n>=0;n--)if(e[n].top<=s+50){t=e[n].id;break}i.forEach(e=>{const s=e.getAttribute("href")===`#${t}`;if(e.classList.toggle("active",s),s){const t=e.offsetTop-n.clientHeight/2;n.scrollTop=t}})}let t=!1;window.addEventListener("scroll",()=>{t||(window.requestAnimationFrame(()=>{s(),t=!1}),t=!0)}),s()})</script></body></html>